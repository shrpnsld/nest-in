#!/bin/bash

#
# Essentials

readonly NEST_IN__SCRIPT_NAME=nest-in

readonly NEST_IN__TS_N='\e[0m'
readonly NEST_IN__TS_B='\e[1m'
readonly NEST_IN__TS_U='\e[4m'
readonly TS_ERROR='\e[0;31m'

NEST_IN__TS_ERR=''
NEST_IN__TS_ERR_END=''
if [ -t 1 ] && [ $(tput colors) \> 0 ]
then
	NEST_IN__TS_ERR="$TS_ERROR"
	NEST_IN__TS_ERR_END="$NEST_IN__TS_N"
fi

readonly NEST_IN__TS_ERR NEST_IN__TS_ERR_END

printf-stderr()
{
	printf "$@" >&2
}

printf-error()
{
	printf-stderr "$NEST_IN__TS_ERR$NEST_IN__SCRIPT_NAME error:$NEST_IN__TS_ERR_END "
	printf-stderr "$@"
	printf-stderr '\n'
}

printf-message()
{
	printf "$@"
	printf '\n'
}

printf-nest-in-message()
{
	printf "${NEST_IN__TS_U}$NEST_IN__SCRIPT_NAME${NEST_IN__TS_N}: "
	printf "$@"
	printf '\n'
}

print-help()
{
	printf \
"${NEST_IN__TS_B}USAGE${NEST_IN__TS_N}
  ${NEST_IN__TS_B}nest-in${NEST_IN__TS_N} [${NEST_IN__TS_U}-dsr${NEST_IN__TS_N}] [${NEST_IN__TS_U}targets...${NEST_IN__TS_N}] [${NEST_IN__TS_U}-k${NEST_IN__TS_N}] -- [${NEST_IN__TS_U}file${NEST_IN__TS_N}]

${NEST_IN__TS_B}OPTIONS${NEST_IN__TS_N}
  [${NEST_IN__TS_U}targets${NEST_IN__TS_N}...]   Specify targets to work with.
  ${NEST_IN__TS_B}-d${NEST_IN__TS_N}             Show dependencies for targets.
  ${NEST_IN__TS_B}-n${NEST_IN__TS_N}             Dry run.
  ${NEST_IN__TS_B}--system-info${NEST_IN__TS_N}  Print detected system information.
  ${NEST_IN__TS_B}--${NEST_IN__TS_N} ${NEST_IN__TS_U}file${NEST_IN__TS_N}        Read nesting info from ${NEST_IN__TS_U}file${NEST_IN__TS_N}.
  ${NEST_IN__TS_B}--${NEST_IN__TS_N}             Read nesting info from from ${NEST_IN__TS_U}stdin${NEST_IN__TS_N}.
  ${NEST_IN__TS_B}-h${NEST_IN__TS_N}             Show this message.

${NEST_IN__TS_B}More information at${NEST_IN__TS_N} ${NEST_IN__TS_U}https://github.com/shrpnsld/nest-in${NEST_IN__TS_N}
"
}

min-number()
{
	local first=$1
	local second=$2

	if [[ $first < $second ]]
	then
		return $first
	else
		return $second
	fi
}

max-number()
{
	local first=$1
	local second=$2

	if [[ $first > $second ]]
	then
		return $first
	else
		return $second
	fi
}

versions-equal()
{
	local first=$1
	local second=$2

	local old_IFS="$IFS"
	IFS='.'

	first=($first)
	second=($second)

	min-number ${#first[@]} ${#second[@]}
	local component_count=$?
	local result=0
	local index
	for (( index = 0; index < component_count; ++index ))
	do
		if [[ ${first[index]} != ${second[index]} ]]
		then
			result=1
			break
		fi
	done

	IFS="$old_IFS"

	return $result
}

#
# Constants

readonly NEST_IN__CONFIG_DIR_PATH="$HOME/.config/$NEST_IN__SCRIPT_NAME"
readonly NEST_IN__CONFIG_FILE_NAME='twigs.txt'
readonly NEST_IN__DEFAULT_TWIGS_PATH="$NEST_IN__CONFIG_DIR_PATH/$NEST_IN__CONFIG_FILE_NAME"
readonly NEST_IN__TARGET_FIRST_STEP_NAME='_FIRST_STEP'
readonly NEST_IN__TARGET_LAST_STEP_NAME='_LAST_STEP'

#
# Options

NEST_IN__TWIGS_PATH="$NEST_IN__DEFAULT_TWIGS_PATH"
NEST_IN__TWIGS_DESCRIPTOR=-1
NEST_IN__ALL_TARGETS=()
NEST_IN__REGULAR_TARGETS=()
NEST_IN__FIRST_STEP=''
NEST_IN__LAST_STEP=''
NEST_IN__INPUT_TARGETS=()

NEST_IN__DO_THE_WORK=:
do-the-work()
{
	"$NEST_IN__DO_THE_WORK" "$@"
}


NEST_IN__DEAL_WITH_SCRIPT=exec-script
deal-with-script()
{
	"$NEST_IN__DEAL_WITH_SCRIPT" "$@"
}

#
# Requirements

extract-value()
{
	local value=$1
	local line=$2

	line="${line#${value}=}"
	line="${line#\"*}"
	line="${line%*\"}"

	printf '%s' "$line"
}

gather-linux-info()
{
	if [ ! -r /etc/os-release ]
	then
		NEST_IN__LINUX_FAMILY=unknown
		NEST_IN__LINUX_DISTRIBUTION=unknown
		NEST_IN__OS_VERSION=unknown
		return
	fi

	local line=$(grep '^ID=' /etc/os-release)
	NEST_IN__LINUX_DISTRIBUTION=$(extract-value 'ID' "$line")

	line=$(grep '^ID_LIKE=' /etc/os-release)
	NEST_IN__LINUX_FAMILY=$(extract-value 'ID_LIKE' "$line")

	line=$(grep '^VERSION_ID=' /etc/os-release)
	NEST_IN__OS_VERSION=$(extract-value 'VERSION_ID' "$line")

	if [[ $NEST_IN__LINUX_FAMILY == *debian* ]] # Elementary OS stores ID_LIKE="ubuntu debian"
	then
		NEST_IN__LINUX_FAMILY='debian'
	elif [[ $NEST_IN__LINUX_FAMILY == *suse* ]] # OpenSuSE stores ID_LIKE="suse opensuse"
	then
		NEST_IN__LINUX_FAMILY='suse'
	elif [ -z "$NEST_IN__LINUX_FAMILY" ]
	then
		if [ -f /etc/arch-release ]
		then
			NEST_IN__LINUX_FAMILY='arch'
		elif [ -f /etc/debian_version ]
		then
			NEST_IN__LINUX_FAMILY='debian'
		elif [ -f /etc/redhat-release ]
		then
			NEST_IN__LINUX_FAMILY='redhat'
		fi
	fi

	if [[ $NEST_IN__LINUX_DISTRIBUTION == opensuse* ]] # OpenSUSE stores ID="opensuse-leap"
	then
		NEST_IN__LINUX_DISTRIBUTION=opensuse
	elif [ -z "$NEST_IN__LINUX_DISTRIBUTION" ]
	then
		if [[ $NEST_IN__LINUX_FAMILY == arch ]]
		then
			NEST_IN__LINUX_DISTRIBUTION=$(lsb_release -id --short | awk '{ print $1 }' | tr '[:upper:]' '[:lower:]')
		elif [[ $NEST_IN__LINUX_FAMILY == debian ]]
		then
			NEST_IN__LINUX_DISTRIBUTION=$(lsb_release -id --short | head -1 | tr '[:upper:]' '[:lower:]')
		elif [[ $NEST_IN__LINUX_FAMILY == redhat ]]
		then
			NEST_IN__LINUX_DISTRIBUTION=$(awk '{ print $1 }' /etc/redhat-release | tr '[:upper:]' '[:lower:]')
		fi
	fi

	# Tails stores VERSION="x.y.z"
	if [ -z "$NEST_IN__OS_VERSION" ]
	then
		line=$(grep '^VERSION=' /etc/os-release)
		local version=$(extract-value 'VERSION' "$line")
		if [[ $version =~ ^[0-9]+[0-9\.]*[0-9]+$ ]]
		then
			NEST_IN__OS_VERSION="$version"
		fi
	fi

	if [ -z "$NEST_IN__OS_VERSION" ]
	then
		if [[ $NEST_IN__LINUX_FAMILY == arch ]]
		then
			NEST_IN__OS_VERSION=$(lsb_release --release --short)
		elif [[ $NEST_IN__LINUX_FAMILY == debian ]]
		then
			NEST_IN__OS_VERSION=$(grep '^DISTRIB_RELEASE' /etc/lsb-release | awk -F= '{ print $2 }')
		elif [[ $NEST_IN__LINUX_FAMILY == redhat ]]
		then
			NEST_IN__OS_VERSION=$(awk '{ print $3 }' /etc/redhat-release)
		fi
	fi
}

gather-system-info()
{
	case "$OSTYPE" in
		darwin*)
			NEST_IN__OS=macos
			NEST_IN__LINUX_FAMILY=''
			NEST_IN__LINUX_DISTRIBUTION=''
			NEST_IN__OS_VERSION=$(sw_vers --productVersion)
			;;

		linux*)
			NEST_IN__OS='linux'
			gather-linux-info
			;;

		cygwin)
			NEST_IN__OS=cygwin
			NEST_IN__LINUX_FAMILY=''
			NEST_IN__LINUX_DISTRIBUTION=''
			NEST_IN__OS_VERSION=''
			;;

		msys)
			NEST_IN__OS=msys
			NEST_IN__LINUX_FAMILY=''
			NEST_IN__LINUX_DISTRIBUTION=''
			NEST_IN__OS_VERSION=''
			;;
	esac

	readonly \
		NEST_IN__OS \
		NEST_IN__LINUX_FAMILY \
		NEST_IN__LINUX_DISTRIBUTION \
		NEST_IN__OS_VERSION
}

print-system-info()
{
	printf 'os: "%s"\n' "$NEST_IN__OS"

	if [ -n "$NEST_IN__LINUX_FAMILY" ]
	then
		printf 'family: "%s"\n' "$NEST_IN__LINUX_FAMILY"
	fi

	if [ -n "$NEST_IN__LINUX_FAMILY" ]
	then
		printf 'distribution: "%s"\n' "$NEST_IN__LINUX_DISTRIBUTION"
	fi

	printf 'version: "%s"\n' "$NEST_IN__OS_VERSION"
}

os()
{
	local name=$1
	local version=$2

	[[ $NEST_IN__OS == $name ]] ||
	[[ $NEST_IN__LINUX_DISTRIBUTION == $name ]] &&

	if [ -n "$version" ]
	then
		versions-equal $NEST_IN__OS_VERSION $version
	fi
}

avail()
{
	local program=$1

	local type_of_object=$(type -t "$program")
	[[ $type_of_object == file ]] || [[ $type_of_object == function ]]
}

macos()
{
	local version=$1

	[[ $NEST_IN__OS == 'macos' ]] &&
	if [ -n "$version" ]
	then
		versions-equal $NEST_IN__OS_VERSION $version
	fi
}

linux()
{
	local family=$1
	local distribution=$2
	local version=$3

	[[ $NEST_IN__OS == 'linux' ]] &&
	if [ -n "$family" ]
	then
		[[ $NEST_IN__LINUX_FAMILY == $family ]]
	fi &&
	if [ -n "$distribution" ]
	then
		[[ $NEST_IN__LINUX_DISTRIBUTION == $distribution ]]
	fi &&
	if [ -n "$version" ]
	then
		versions-equal $NEST_IN__OS_VERSION $version
	fi
}

debian() { linux 'debian' "$@"; }
ubuntu() { debian 'ubuntu' "$@"; }
elementary() { debian 'elementary' "$@"; }
kali() { debian 'kali' "$@"; } # not tested yet
tails() { debian 'tails' "$@"; } # not tested yet

redhat() { linux 'redhat' "$@"; }
fedora() { redhat 'fedora' "$@"; }

arch() { linux 'arch' "$@"; }
manjaro() { arch 'manjaro' "$@"; }

suse() { linux 'suse' "$@"; }
opensuse() { suse 'opensuse' "$@"; }

cygwin() { [[ $NEST_IN__OS == 'cygwin' ]]; }

#
# Functions

readonly PARAMETER_TYPE_OPTION=1
readonly PARAMETER_TYPE_LONG_OPTION=2
readonly PARAMETER_TYPE_TARGET=3
readonly PARAMETER_TYPE_DELIMITER=4
readonly PARAMETER_TYPE_BAD=255
PARAMETER_TYPE_RETURN__PARAMETER=''
parameter-type()
{
	local string=$1

	if [[ ${string:0:2} == '--' && ${#string} == 2 ]]
	then
		return $PARAMETER_TYPE_DELIMITER
	fi

	if [[ ${string:0:2} == '--' ]]
	then
		PARAMETER_TYPE_RETURN__PARAMETER="${string#--}"
		return $PARAMETER_TYPE_LONG_OPTION
	fi

	if [[ ${string:0:1} == '-' ]]
	then
		PARAMETER_TYPE_RETURN__PARAMETER="${string#-}"
		return $PARAMETER_TYPE_OPTION
	fi

	if [[ $string =~ ^[a-zA-Z]+[a-zA-Z0-9_\-]*$ ]]
	then
		PARAMETER_TYPE_RETURN__PARAMETER="$string"
		return $PARAMETER_TYPE_TARGET
	fi

	return $PARAMETER_TYPE_BAD
}

PARSE_OPTION_UNKNOWN_OPTION=255
parse-option()
{
	local option=$1
	local value=$2

	case "$option" in
		d)
			NEST_IN__DO_THE_WORK=show-targets
			;;

		n)
			NEST_IN__DEAL_WITH_SCRIPT=:
			;;

		system-info)
			print-system-info
			exit
			;;

		h)
			print-help
			exit
			;;

		*)
			return $PARSE_OPTION_UNKNOWN_OPTION
			;;
	esac
}

parse-arguments()
{
	local parameters=("$@")

	local parameter_index
	for (( parameter_index = 0; parameter_index < ${#parameters[@]}; ++parameter_index ))
	do
		local parameter
		parameter-type "${parameters[$parameter_index]}"
		local parameter_type=$?
		parameter="$PARAMETER_TYPE_RETURN__PARAMETER"
		case $parameter_type in
			$PARAMETER_TYPE_OPTION)
				local value="${parameters[$parameter_index + 1]}"
				local option_index
				for (( option_index = 0; option_index < ${#parameter}; ++option_index ))
				do
					local option="${parameter:$option_index:1}"
					parse-option "$option" "$value"
					local retval=$?
					case $retval in
						$PARSE_OPTION_UNKNOWN_OPTION)
							printf-error 'unknown option "%s"' "$option"
							return 1
							;;

						*)
							(( parameter_index += retval ))
							: # so the result of arithmetic above does not considered as a result of case-clause execution
							;;
					esac
				done

				continue
				;;

			$PARAMETER_TYPE_LONG_OPTION)
				parse-option "$parameter" "$value"
				continue
				;;

			$PARAMETER_TYPE_TARGET)
				NEST_IN__INPUT_TARGETS+=("$parameter")
				;;

			$PARAMETER_TYPE_DELIMITER)
				(( ++parameter_index ))
				NEST_IN__TWIGS_PATH="${parameters[$parameter_index]}"
				break
				;;

			$PARAMETER_TYPE_BAD)
				printf-error 'bad parameter format "%s"' "$parameter"
				return 1
				;;
		esac
	done
}

validate-and-apply-options()
{
	if [ -z "$NEST_IN__TWIGS_PATH" ]
	then
		NEST_IN__TWIGS_DESCRIPTOR=0
	else
		NEST_IN__TWIGS_DESCRIPTOR=3
		open-file $NEST_IN__TWIGS_DESCRIPTOR "$NEST_IN__TWIGS_PATH" >/dev/null 2>&1
		if [ $? != 0 ]
		then
			printf-error 'failed to open config file "%s"' "$NEST_IN__TWIGS_PATH"
			return 1
		fi
	fi

	if [[ $NEST_IN__DO_THE_WORK == ':' ]]
	then
		NEST_IN__DO_THE_WORK=start-nesting
	fi
}

open-file()
{
	local descriptor=$1
	local path=$2

	eval "exec $descriptor< \"$path\""
	if [ $? != 0 ]
	then
		return 1
	fi

	trap "exec $descriptor>&-" EXIT
}

FILE_READ_LINE_RETURN__LINE_NUMBER=0

FILE_PEEK_LINE_RETURN__LINE=''
FILE_PEEK_LINE_RETURN__PEEKED=false
file-peek-line()
{
	local descriptor=$1

	if $FILE_PEEK_LINE_RETURN__PEEKED
	then
		return
	fi

	read -u $descriptor -r FILE_PEEK_LINE_RETURN__LINE
	if [ $? != 0 ]
	then
		FILE_PEEK_LINE_RETURN__PEEKED=false
		return 1
	fi

	FILE_PEEK_LINE_RETURN__PEEKED=true
	(( ++FILE_READ_LINE_RETURN__LINE_NUMBER ))
}

FILE_READ_LINE_RETURN__LINE=''
file-read-line()
{
	local descriptor=$1

	if $FILE_PEEK_LINE_RETURN__PEEKED
	then
		FILE_READ_LINE_RETURN__LINE="$FILE_PEEK_LINE_RETURN__LINE"
		FILE_PEEK_LINE_RETURN__LINE=''
		FILE_PEEK_LINE_RETURN__PEEKED=false
	else
		read -u $descriptor -r FILE_READ_LINE_RETURN__LINE
		if [ $? != 0 ]
		then
			return 1
		fi

		FILE_PEEK_LINE_RETURN__LINE=''
		FILE_PEEK_LINE_RETURN__PEEKED=false
		(( ++FILE_READ_LINE_RETURN__LINE_NUMBER ))
	fi
}

next-non-empty-line()
{
	local descriptor=$1

	while true
	do
		if ! file-peek-line $descriptor
		then
			return
		fi

		if [ -n "$FILE_PEEK_LINE_RETURN__LINE" ]
		then
			break
		fi

		file-read-line $descriptor
	done
}

is-target-declaration()
{
	local line=$1

	# Example
	# target-name
	[[ $line =~ ^[[:alpha:]]+[[:alnum:]_\-]*[[:blank:]]*!?[[:blank:]]*$ ]] ||
	#            target-name...............             !

	# Example
	# target-name! / [requirement:specifier] [requirement] another-target and-another
	#                                                                               (                           |                                       |                   )(                                       |                                                   |                               )
	[[ $line =~ ^[[:alpha:]]+[[:alnum:]_\-]*[[:blank:]]*!?[[:blank:]]*\/[[:blank:]]*([[:alpha:]]+[[:alnum:]_\-]*|\[[[:alpha:]_\-]+\:[[:alnum:]:_\.\-]+\]|\[[[:alpha:]_\-]+\])([[:blank:]]+[[:alpha:]]+[[:alnum:]_\-]*|[[:blank:]]+\[[[:alpha:]_\-]+\:[[:alnum:]:_\.\-]+\]|[[:blank:]]+\[[[:alpha:]_\-]+\])*[[:blank:]]*$ ]] ||
	#            target-name................            !              /             dependency-name............  [requirement.... :specifier........ ]  [requirement..... ]              dependency-name............              [requirement.... :specifier......... ]              [requirement.... ]

	[[ $line =~ ^(\+|\-)[[:blank:]]*$ ]] ||

	# Example + / [requirement:specifier] [requirement]
	#            (  |  )                          (                                       |                   )(                                                   |                               )
	[[ $line =~ ^(\+|\-)[[:blank:]]*\/[[:blank:]]*(\[[[:alpha:]_\-]+\:[[:alnum:]:_\.\-]+\]|\[[[:alpha:]_\-]+\])([[:blank:]]+\[[[:alpha:]_\-]+\:[[:alnum:]:_\.\-]+\]|[[:blank:]]+\[[[:alpha:]_\-]+\])*$ ]]
	#              +  -              /              [requirement.... :specifier......... ]  [requirement.... ]               [requirement.... :specifier......... ]              [requirement.... ]
}

is-script-declaration()
{
	local line=$1

	[ -z "$line" ] || [[ $line =~ ^[[:blank:]]+.*$ ]]
}

EXTRACT_TARGET_RETURN__TARGET=''
extract-target()
{
	local line=$1

	line="${line%%/*}"
	line="${line%%!*}"
	EXTRACT_TARGET_RETURN__TARGET="${line%% *}"
}

readonly TARGET_TYPE_CODE__REGULAR=1
readonly TARGET_TYPE_CODE__FIRST_STEP=2
readonly TARGET_TYPE_CODE__LAST_STEP=3
readonly TARGET_TYPE_CODE__DEDICATED=4
target-type()
{
	if [[ $line =~ ^\+[[:blank:]]* ]]
	then
		return $TARGET_TYPE_CODE__FIRST_STEP
	elif [[ $line =~ ^\-[[:blank:]]* ]]
	then
		return $TARGET_TYPE_CODE__LAST_STEP
	elif [[ $line == *!* ]]
	then
		return $TARGET_TYPE_CODE__DEDICATED
	else
		return $TARGET_TYPE_CODE__REGULAR
	fi

}

EXTRACT_REQS_AND_DEPS_RETURN__REQUIREMENTS=()
EXTRACT_REQS_AND_DEPS_RETURN__DEPENDENCIES=()
extract-reqs-and-deps()
{
	local line=$1

	EXTRACT_REQS_AND_DEPS_RETURN__REQUIREMENTS=()
	EXTRACT_REQS_AND_DEPS_RETURN__DEPENDENCIES=()

	if [[ $line != */* ]]
	then
		return
	fi

	line=${line#*/}

	local old_IFS="$IFS"
	IFS=$' '

	local tokens=(${line#*/})
	for token in "${tokens[@]}"
	do
		if [[ ${token:0:1} == '[' ]]
		then
			token=${token#[}
			token=${token%]}
			EXTRACT_REQS_AND_DEPS_RETURN__REQUIREMENTS+=("$token")
		else
			EXTRACT_REQS_AND_DEPS_RETURN__DEPENDENCIES+=("$token")
		fi
	done

	IFS="$old_IFS"
}

TRIM_STRING_RETURN__STRING=''
trim-string()
{
	local string=$1

	TRIM_STRING_RETURN__STRING=''

    string="${string#"${string%%[![:space:]]*}"}"
    string="${string%"${string##*[![:space:]]}"}"
	TRIM_STRING_RETURN__STRING="$string"
}

array-contains-item()
{
	local item=$1
	local array=("${@:2}")

	local current
	for current in ${array[@]}
	do
		if [[ $current == $item ]]
		then
			return 0
		fi
	done

	return 1
}

normalize-target-name()
{
	local target=$1

	case "$target" in
		$NEST_IN__TARGET_FIRST_STEP_NAME)
			printf '%s' '+'
			;;

		$NEST_IN__TARGET_LAST_STEP_NAME)
			printf '%s' '-'
			;;

		*)
			printf '%s' "$target"
			;;
	esac
}

variable-name-from-target()
{
	local string=$1

	tr '-' '_' <<< "$string"
}

is-target-marked()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_marked="NEST_IN__MARKED_${variable_name}"
	[[ ${!target_marked} != '' ]] && ${!target_marked}
}

target-unmark()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_marked="NEST_IN__MARKED_${variable_name}"
	printf -v "$target_marked" false
}

target-mark()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_marked="NEST_IN__MARKED_${variable_name}"
	printf -v "$target_marked" true
}

targets-unmark()
{
	local targets=("$@")

	local target
	for target in "${targets[@]}"
	do
		target-unmark "$target"
	done
}

TARGET_DECLARATION_RETURN__DECLARATION=''
TARGET_DECLARATION_RETURN__LINE_NUMBER=''
target-declaration()
{
	local target=$1
	local variant=$2

	if [ -z "$variant" ]
	then
		variant=0
	fi

	local variable_name=$(variable-name-from-target "$target")
	eval "TARGET_DECLARATION_RETURN__DECLARATION=(\"\${NEST_IN__DECLARATIONS_${variable_name}[$variant]}\")"
	eval "TARGET_DECLARATION_RETURN__LINE_NUMBER=(\"\${NEST_IN__DECLARATION_LINE_NUMBERS_${variable_name}[$variant]}\")"
}

target-add-declaration()
{
	local target=$1
	local line_number=$3
	local declaration=$2

	local variable_name=$(variable-name-from-target "$target")
	eval "NEST_IN__DECLARATIONS_${variable_name}+=(\"$declaration\")"
	eval "NEST_IN__DECLARATION_LINE_NUMBERS_${variable_name}+=($line_number)"
}

target-use-declaration-variant()
{
	local target=$1
	local variant=$2

	target-declaration "$target" $variant
	local declaration="$TARGET_DECLARATION_RETURN__DECLARATION"
	local line_number=$TARGET_DECLARATION_RETURN__LINE_NUMBER

	local variable_name=$(variable-name-from-target "$target")
	eval "NEST_IN__DECLARATIONS_${variable_name}[0]=\"$declaration\""
	eval "NEST_IN__DECLARATION_LINE_NUMBERS_${variable_name}[0]=$line_number"
}

TARGET_VARIANT_COUNT_RETURN__COUNT=
target-variant-count()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	eval "TARGET_VARIANT_COUNT_RETURN__COUNT=\${#NEST_IN__DECLARATIONS_${variable_name}[@]}"

}

TARGET_REQUIREMENTS_RETURN__REQUIREMENTS=()
target-requirements()
{
	local target=$1
	local variant=$2

	if [ -z "$variant" ]
	then
		variant=0
	fi

	local variable_name=$(variable-name-from-target "$target")
	local requirements
	eval "requirements=(\"\${NEST_IN__REQUIREMENTS_${variable_name}[$variant]}\")"

	local old_IFS="$IFS"
	IFS=$' '
	TARGET_REQUIREMENTS_RETURN__REQUIREMENTS=(${requirements[@]})
	IFS="$old_IFS"
}

target-add-requirements()
{
	local target=$1
	local requirements=("${@:2}")

	local old_IFS="$IFS"
	IFS=$' '
	requirements="${requirements[@]}"
	IFS="$old_IFS"

	local target_variable_name=$(variable-name-from-target "$target")
	eval "NEST_IN__REQUIREMENTS_${target_variable_name}+=(\"$requirements\")"
}

target-requirements-resolved()
{
	local target=$1

	local target_variable_name=$(variable-name-from-target "$target")
	eval "[[ \$NEST_IN__REQUIREMENTS_RESOLVED_${target_variable_name} ]]"
}

target-mark-requirements-resolved()
{
	local target=$1

	local target_variable_name=$(variable-name-from-target "$target")
	eval "NEST_IN__REQUIREMENTS_RESOLVED_${target_variable_name}=true"
}

TARGET_DEPENDENCIES_RETURN__DEPENDENCIES=()
target-dependencies()
{
	local target=$1
	local variant=$2

	if [ -z "$variant" ]
	then
		variant=0
	fi

	local variable_name=$(variable-name-from-target "$target")
	local dependencies
	eval "dependencies=(\"\${NEST_IN__DEPENDENCIES_${variable_name}[$variant]}\")"

	local old_IFS="$IFS"
	IFS=$' '
	TARGET_DEPENDENCIES_RETURN__DEPENDENCIES=(${dependencies[@]})
	IFS="$old_IFS"
}

target-dependencies-recursive-impl()
{
	local target=$1

	target-dependencies "$target"
	local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
	if [[ ${#dependencies[@]} == 0 ]]
	then
		return
	fi

	TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES+=("${dependencies[@]}")

	for dependency in "${dependencies[@]}"
	do
		target-dependencies-recursive-impl "$dependency"
	done
}

TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES=()
target-dependencies-recursive()
{
	local target=$1

	TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES=()

	target-dependencies-recursive-impl "$target"
	TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES=($(IFS=$'\n' sort <<< "${TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES[*]}" | uniq))
}

target-add-dependencies()
{
	local target=$1
	local dependencies=("${@:2}")

	local old_IFS="$IFS"
	IFS=$' '
	dependencies="${dependencies[@]}"
	IFS="$old_IFS"

	local target_variable_name=$(variable-name-from-target "$target")
	eval "NEST_IN__DEPENDENCIES_${target_variable_name}+=(\"$dependencies\")"
}

target-use-dependencies-variant()
{
	local target=$1
	local variant=$2

	local old_IFS="$IFS"
	IFS=$' '
	target-dependencies "$target" $variant
	local dependencies="${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}"
	IFS="$old_IFS"

	local target_variable_name=$(variable-name-from-target "$target")
	eval "NEST_IN__DEPENDENCIES_${target_variable_name}[0]=\"$dependencies\""
}

TARGET_SCRIPT_RETURN__SCRIPT=()
target-script()
{
	local target=$1
	local variant=$2

	if [ -z "$variant" ]
	then
		variant=0
	fi

	local variable_name=$(variable-name-from-target "$target")
	eval "TARGET_SCRIPT_RETURN__SCRIPT=(\"\${NEST_IN__SCRIPT_${variable_name}[$variant]}\")"

	local old_IFS="$IFS"
	IFS=$'\n'
	TARGET_SCRIPT_RETURN__SCRIPT=(${TARGET_SCRIPT_RETURN__SCRIPT[@]})
	IFS="$old_IFS"
}

target-add-script()
{
	local target=$1
	local script=("${@:2}")

	local variable_name=$(variable-name-from-target "$target")
	eval "NEST_IN__SCRIPT_${variable_name}+=(\"\$script\")"
}

target-use-script-variant()
{
	local target=$1
	local variant=$2

	local variable_name=$(variable-name-from-target "$target")
	local script
	eval "script=(\"\${NEST_IN__SCRIPT_${variable_name}[$variant]}\")"

	eval "NEST_IN__SCRIPT_${variable_name}[0]=\"\$script\""
}

target-use-variant()
{
	local target=$1
	local variant=$2

	target-use-declaration-variant "$target" $variant
	target-use-dependencies-variant "$target" $variant
	target-use-script-variant "$target" $variant
	target-mark-requirements-resolved "$target"
}

READ_TARGET_SCRIPT_RETURN__SCRIPT=''
read-target-script()
{
	local descriptor=$1

	READ_TARGET_SCRIPT_RETURN__SCRIPT=''

	while true
	do
		if ! file-peek-line $descriptor
		then
			return
		fi

		if ! is-script-declaration "$FILE_PEEK_LINE_RETURN__LINE"
		then
			break
		fi

		file-read-line $descriptor
		trim-string "$FILE_READ_LINE_RETURN__LINE"
		local line="${TRIM_STRING_RETURN__STRING}"
		if [ -n "$line" ]
		then
			READ_TARGET_SCRIPT_RETURN__SCRIPT+="$line"$'\n'
		fi
	done
}

PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE=()
predicate-from-requirement()
{
	local requirement=$1

	PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE=()

	local old_IFS="$IFS"
	IFS=$':'

	PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE=(${requirement[@]})

	IFS="$old_IFS"
}

predicate-defined()
{
	local name=$1

	declare -f "$name" > /dev/null
}

readonly CHECK_REQUIREMENTS_CODE__UNKNOWN_NAME=255
CHECK_REQUIREMENTS_RETURN__VIOLATING_NAME=''
check-requirements()
{
	local requirements=("$@")

	for requirement in "${requirements[@]}"
	do
		predicate-from-requirement "$requirement"
		local predicate=("${PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE[@]}")
		if ! predicate-defined "${predicate[0]}"
		then
			CHECK_REQUIREMENTS_RETURN__VIOLATING_NAME="${predicate[0]}"
			return $CHECK_REQUIREMENTS_CODE__UNKNOWN_NAME
		fi

		if ! "${predicate[@]}"
		then
			return 1
		fi
	done
}

gather-twigs()
{
	local descriptor=$1

	local old_IFS="$IFS"
	IFS=

	while true
	do
		if ! next-non-empty-line $descriptor || ! file-peek-line $descriptor
		then
			break
		fi

		local line="$FILE_PEEK_LINE_RETURN__LINE"
		if ! is-target-declaration "$line"
		then
			printf-error 'bad declaration format\nline %d: %s' $FILE_READ_LINE_RETURN__LINE_NUMBER "$line"
			return 1
		fi

		file-read-line $descriptor
		line="$FILE_READ_LINE_RETURN__LINE"
		local line_number=$FILE_READ_LINE_RETURN__LINE_NUMBER
		target-type "$line"
		local target_type=$?

		local target
		if [[ $target_type == $TARGET_TYPE_CODE__FIRST_STEP ]]
		then
			NEST_IN__FIRST_STEP="$NEST_IN__TARGET_FIRST_STEP_NAME"
			target="$NEST_IN__TARGET_FIRST_STEP_NAME"
		elif [[ $target_type == $TARGET_TYPE_CODE__LAST_STEP ]]
		then
			NEST_IN__LAST_STEP="$NEST_IN__TARGET_LAST_STEP_NAME"
			target="$NEST_IN__TARGET_LAST_STEP_NAME"
		else
			extract-target "$line"
			target="$EXTRACT_TARGET_RETURN__TARGET"
		fi

		target-add-declaration "$target" "$line" $line_number

		extract-reqs-and-deps "$line"
		local dependencies=("${EXTRACT_REQS_AND_DEPS_RETURN__DEPENDENCIES[@]}")
		local requirements=("${EXTRACT_REQS_AND_DEPS_RETURN__REQUIREMENTS[@]}")
		target-add-requirements "$target" "${requirements[@]}"
		target-add-dependencies "$target" "${dependencies[@]}"

		if [[ $target_type == $TARGET_TYPE_CODE__REGULAR ]] && ! array-contains-item "$target" "${NEST_IN__REGULAR_TARGETS[@]}"
		then
			NEST_IN__REGULAR_TARGETS+=("$target")
		fi

		if ! array-contains-item "$target" "${NEST_IN__ALL_TARGETS[@]}"
		then
			NEST_IN__ALL_TARGETS+=("$target")
		fi

		if ! file-peek-line $descriptor
		then
			break
		fi

		line="$FILE_PEEK_LINE_RETURN__LINE"
		if ! is-script-declaration "$line"
		then
			continue
		fi

		if ! read-target-script $descriptor
		then
			break
		fi

		local script="${READ_TARGET_SCRIPT_RETURN__SCRIPT[@]}"
		target-add-script "$target" "$script"
	done
	IFS="$old_IFS"

	targets-unmark "${NEST_IN__ALL_TARGETS[@]}"
}

make-error-message-unknown-requirement()
{
	local target=$1
	local index=$2
	local requirement=$3

	target-declaration "$target" $index
	local line_number=$TARGET_DECLARATION_RETURN__LINE_NUMBER
	local declaration="$TARGET_DECLARATION_RETURN__DECLARATION"
	printf 'unknown requirement "%s" for "%s"\n' "$requirement" $(normalize-target-name "$target")
	printf 'line %d: %s\n' $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
}

make-error-message-none-requirements-fulfilled()
{
	local target=$1

	printf 'none of "%s" variants have requirements fulfilled' $(normalize-target-name "$target")
}

make-error-message-multiple-requirements-fulfilled()
{
	local target=$1
	local variants=("${@:2}")

	printf 'multiple "%s" variants have their requirements fulfilled\n\n%s\n' $(normalize-target-name "$target") $(realpath "$NEST_IN__TWIGS_PATH")

	local variant
	for variant in "${variants[@]}"
	do
		target-declaration "$target" $variant
		local line_number=$TARGET_DECLARATION_RETURN__LINE_NUMBER
		local declaration="$TARGET_DECLARATION_RETURN__DECLARATION"
		printf 'line %d: %s\n' $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
	done
}

make-error-message-multiple-declarations()
{
	local target=$1
	local variants=("${@:2}")

	printf 'multiple declarations for "%s"\n\n%s\n' $(normalize-target-name "$target") $(realpath "$NEST_IN__TWIGS_PATH")

	local variant
	for variant in "${variants[@]}"
	do
		target-declaration "$target" $variant
		local line_number=$TARGET_DECLARATION_RETURN__LINE_NUMBER
		local declaration="$TARGET_DECLARATION_RETURN__DECLARATION"
		printf 'line %d: %s\n' $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
	done
}

make-error-message-unknown-dependency()
{
	local target=$1
	local dependency=$2

	target-declaration "$target"
	printf 'unknown dependency "%s" for "%s"\n\n%s\nline %d: %s\n' "$dependency" "$target" $(realpath "$NEST_IN__TWIGS_PATH") $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
}

make-error-message-circular-dependency()
{
	local dependency_path=("$@")

	printf 'circular dependency found\n'
	printf '%s -> ' "${dependency_path[@]}"
	printf '%s' "${dependency_path[0]}"

	printf '\n\n%s\n' $(realpath "$NEST_IN__TWIGS_PATH")
	local target
	for target in "${dependency_path[@]}"
	do
		target-declaration "$target"
		printf 'line %d: %s\n' $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
	done
}

readonly RESOLVE_REQUIREMENTS_CODE__UNKNOWN_NAME=255
RESOLVE_REQUIREMENTS_RETURN__UNKNOWN_NAME=''
resolve-requirements()
{
	local requirements=("$@")

	for requirement in "${requirements[@]}"
	do
		predicate-from-requirement "$requirement"
		local predicate=("${PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE[@]}")
		if ! predicate-defined "${predicate[0]}"
		then
			RESOLVE_REQUIREMENTS_RETURN__UNKNOWN_NAME="${predicate[0]}"
			return $RESOLVE_REQUIREMENTS_CODE__UNKNOWN_NAME
		fi

		if ! "${predicate[@]}"
		then
			return 1
		fi
	done
}

RESOLVE_REQUIREMENTS_FOR_TARGET_RETURN__ERROR_MESSAGE=''
resolve-requirements-for-target()
{
	local target=$1

	if target-requirements-resolved "$target"
	then
		return
	fi

	local resolved_variants=()
	local no_requirements_variants=()

	local variable_name=$(variable-name-from-target)
	local no_requirements_count=0

	target-variant-count "$target"
	local variant_count=$TARGET_VARIANT_COUNT_RETURN__COUNT
	local variant
	for (( variant = 0; variant < variant_count; ++variant ))
	do
		target-requirements "$target" $variant
		local requirements=("${TARGET_REQUIREMENTS_RETURN__REQUIREMENTS[@]}")
		if [[ ${#requirements[@]} == 0 ]]
		then
			no_requirements_variants+=($variant)
			continue
		fi

		resolve-requirements "${requirements[@]}"
		local retval=$?
		if [[ $retval == $RESOLVE_REQUIREMENTS_CODE__UNKNOWN_NAME ]]
		then
			RESOLVE_REQUIREMENTS_FOR_TARGET_RETURN__ERROR_MESSAGE=$(make-error-message-unknown-requirement "$target" $variant $RESOLVE_REQUIREMENTS_RETURN__UNKNOWN_NAME)
			return 1
		fi

		if [[ $retval == 0 ]]
		then
			resolved_variants+=($variant)
		fi
	done

	if [[ ${#resolved_variants[@]} == 0 && ${#no_requirements_variants[@]} == 0 ]]
	then
		RESOLVE_REQUIREMENTS_FOR_TARGET_RETURN__ERROR_MESSAGE=$(make-error-message-none-requirements-fulfilled "$target")
		return 1
	elif [[ ${#resolved_variants[@]} > 1 ]]
	then
		RESOLVE_REQUIREMENTS_FOR_TARGET_RETURN__ERROR_MESSAGE=$(make-error-message-multiple-requirements-fulfilled "$target" "${resolved_variants[@]}")
		return 1
	elif [[ ${#no_requirements_variants[@]} > 1 ]]
	then
		RESOLVE_REQUIREMENTS_FOR_TARGET_RETURN__ERROR_MESSAGE=$(make-error-message-multiple-declarations "$target" "${no_requirements_variants[@]}")
		return 1
	fi

	if [[ ${#resolved_variants[@]} == 1 ]]
	then
		target-use-variant "$target" ${resolved_variants[0]}
	else
		target-use-variant "$target" ${no_requirements_variants[0]}
	fi
}

RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_FOR_TARGET_RETURN__ERROR_MESSAGE=''
resolve-requirements-and-verify-dependencies-for-target()
{
	local top_target=$1
	local target=$2
	local dependency_path=("${@:3}")

	if is-target-marked "$target"
	then
		return
	fi

	target-mark "$target"

	target-dependencies "$target"
	local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
	local dependency
	for dependency in "${dependencies[@]}"
	do
		target-declaration "$dependency"
		if [ -z "$TARGET_DECLARATION_RETURN__DECLARATION" ]
		then
			RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_FOR_TARGET_RETURN__ERROR_MESSAGE=$(make-error-message-unknown-dependency "$target" "$dependency")
			return 1
		fi

		if ! resolve-requirements-for-target "$dependency"
		then
			RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_FOR_TARGET_RETURN__ERROR_MESSAGE="$RESOLVE_REQUIREMENTS_FOR_TARGET_RETURN__ERROR_MESSAGE"
			return 1
		fi

		if [[ $dependency == $top_target ]]
		then
			RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_FOR_TARGET_RETURN__ERROR_MESSAGE=$(make-error-message-circular-dependency "${dependency_path[@]}")
			return 1
		fi

		if ! resolve-requirements-and-verify-dependencies-for-target "$top_target" "$dependency" "${dependency_path[@]}" "$dependency"
		then
			return 1
		fi
	done
}

resolve-requirements-and-verify-dependencies()
{
	local targets=("$@")

	local target
	for target in "${targets[@]}"
	do
		target-declaration "$target"
		if [ -z "$TARGET_DECLARATION_RETURN__DECLARATION" ]
		then
			printf-error 'unknown target "%s"' "$target"
			return 1
		fi

		if ! resolve-requirements-for-target "$target"
		then
			printf-error "$RESOLVE_REQUIREMENTS_FOR_TARGET_RETURN__ERROR_MESSAGE"
			return 1
		fi

		target-dependencies "$target"
		local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
		if ! resolve-requirements-and-verify-dependencies-for-target "$target" "$target" "$target"
		then
			printf-error "$RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_FOR_TARGET_RETURN__ERROR_MESSAGE"
			return 1
		fi

		targets-unmark "${NEST_IN__ALL_TARGETS[@]}"
	done
}

show-target-dependencies()
{
	local target=$1
	local indent=$2

	target-dependencies-recursive "$target"
	local dependencies=("${TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES[@]}")

	local dependency
	for dependency in "${dependencies[@]}"
	do
		printf "\n%s%s" "$indent" "$dependency"
	done

	printf '\n'
}

show-targets()
{
	local targets=("$@")

	local target="${targets[0]}"
	printf "%s" "$target"
	show-target-dependencies "$target" '    '

	for target in "${targets[@]:1}"
	do
		printf "\n%s" "$target"
		show-target-dependencies "$target" '    '
	done
}

EXEC_SCRIPT_RETURN__FAILED_LINE=''
exec-script()
{
	local nest_in__script=("$@")

	EXEC_SCRIPT_RETURN__FAILED_LINE=''

	local nest_in__pwd="$PWD"
	local nest_in__line
	for nest_in__line in "${nest_in__script[@]}"
	do
		eval "$nest_in__line"
		if [ $? != 0 ]
		then
			EXEC_SCRIPT_RETURN__FAILED_LINE="$nest_in__line"
			return 1
		fi
	done

	cd "$nest_in__pwd"
}

nest-in-targets()
{
	local targets=("$@")

	local target
	for target in "${targets[@]}"
	do
		if is-target-marked "$target"
		then
			continue
		fi

		target-dependencies "$target"
		local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
		if [[ ${#dependencies[@]} > 0 ]]
		then
			printf-nest-in-message 'resolving dependencies for %s...' "$target"
			if ! nest-in-targets "${dependencies[@]}"
			then
				return 1
			fi
		fi

		target-script "$target"
		local script=("${TARGET_SCRIPT_RETURN__SCRIPT[@]}")
		if [[ ${#script[@]} > 0 ]]
		then
			printf-nest-in-message 'working on %s...' "$target"
			if ! deal-with-script "${script[@]}"
			then
				printf-error 'failed to install "%s"\nthe following command returned non-zero:\n> %s' $(normalize-target-name "$target") "$EXEC_SCRIPT_RETURN__FAILED_LINE"
				return 1
			fi
		fi

		target-mark "$target"
	done
}

start-nesting()
{
	printf-message 'Nesting...'

	target-script "$NEST_IN__FIRST_STEP"
	local script=("${TARGET_SCRIPT_RETURN__SCRIPT[@]}")
	if [[ ${#script[@]} > 0 ]]
	then
		printf-nest-in-message 'first step...'
		if ! deal-with-script "${script[@]}"
		then
			printf-error 'first step failed\nthe following command returned non-zero:\n> %s' "$EXEC_SCRIPT_RETURN__FAILED_LINE"
			return 1
		fi
	fi

	if ! nest-in-targets "$@"
	then
		return 1
	fi

	target-script "$NEST_IN__LAST_STEP"
	script=("${TARGET_SCRIPT_RETURN__SCRIPT[@]}")
	if [[ ${#script[@]} > 0 ]]
	then
		printf-nest-in-message 'last step...'
		if ! deal-with-script "${script[@]}"
		then
			printf-error 'last step failed\nthe following command returned non-zero:\n> %s' "$EXEC_SCRIPT_RETURN__FAILED_LINE"
			return 1
		fi
	fi

	printf-message '\nNesting finished.\nWelcome home!'
}

#
# Main

gather-system-info

{ # Deal with arguments
	if ! parse-arguments "$@" || ! validate-and-apply-options
	then
		exit 1
	fi
}

{ # Do the work
	printf-message 'Gathering twigs...'
	if ! gather-twigs $NEST_IN__TWIGS_DESCRIPTOR
	then
		exit 1
	fi

	if [[ ${#NEST_IN__INPUT_TARGETS[@]} == 0 ]]
	then
		targets=("${NEST_IN__REGULAR_TARGETS[@]}")
	else
		targets=("${NEST_IN__INPUT_TARGETS[@]}")
	fi

	if ! resolve-requirements-and-verify-dependencies "${targets[@]}" $NEST_IN__FIRST_STEP $NEST_IN__LAST_STEP
	then
		exit 1
	fi

	do-the-work "${targets[@]}"
}

