#!/bin/bash

#
# Essentials

readonly UTILITY_NAME=nest-in

readonly TS_N='\e[0m'
readonly TS_B='\e[1m'
readonly TS_U='\e[4m'
readonly TS_RED='\e[0;31m'
readonly TS_GREEN='\e[0;32m'
readonly TS_R='\e[7m'

TS_TARGET_TITLE=''
TS_TARGET_TITLE_END=''
TS_USER=''
TS_USER_END=''
TS_PROMPT=''
TS_PROMPT_END=''
TS_ERR=''
TS_ERR_END=''
if [ -t 1 ] && [ $(tput colors) -gt 0 ]
then
	TS_TARGET_TITLE="$TS_R"
	TS_TARGET_TITLE_END="$TS_N"
	TS_USER="$TS_B"
	TS_USER_END="$TS_N"
	TS_PROMPT="$TS_GREEN"
	TS_PROMPT_END="$TS_N"
	TS_ERR="$TS_RED"
	TS_ERR_END="$TS_N"
fi

readonly TS_TARGET_TITLE
readonly TS_TARGET_TITLE_END
readonly TS_USER
readonly TS_USER_END
readonly TS_PROMPT
readonly TS_PROMPT_END
readonly TS_ERR
readonly TS_ERR_END

printf-error()
{
	printf "$TS_ERR$UTILITY_NAME error:$TS_ERR_END " >&2
	printf "$@" >&2
	printf '\n' >&2
}

printf-message()
{
	printf "$@"
	printf '\n'
}

print-help()
{
	printf \
"${TS_B}USAGE${TS_N}
  ${TS_B}nest-in${TS_N} ${TS_U}twigs-file${TS_N} [${TS_U}-dsni${TS_N}] [-- ${TS_U}targets${TS_N} ${TS_U}...${TS_N}]

${TS_B}OPTIONS${TS_N}
  ${TS_B}-d, --dependencies${TS_N}    Show dependencies for targets.
  ${TS_B}-n, --dry-run${TS_N}         Do not run scripts, only show them.
  ${TS_B}-i, --system-info${TS_N}     Print detected system information.
  ${TS_B}--${TS_N} ${TS_U}targets${TS_N} ${TS_U}...${TS_N}        Targets to work with.
  ${TS_B}-h${TS_N}                    Show this message.

${TS_B}More information at${TS_N} ${TS_U}https://github.com/shrpnsld/nest-in${TS_N}
"
}

min-number()
{
	if [[ $1 < $2 ]]
	then
		return $1
	else
		return $2
	fi
}

versions-equal()
{
	local first=$1
	local second=$2

	local old_IFS="$IFS"
	IFS='.'

	first=($first)
	second=($second)

	min-number ${#first[@]} ${#second[@]}
	local component_count=$?
	local result=0
	local index
	for (( index = 0; index < component_count; ++index ))
	do
		if [[ ${first[index]} != ${second[index]} ]]
		then
			result=1
			break
		fi
	done

	IFS="$old_IFS"

	return $result
}

#
# Constants

readonly TMP_WORK_DIR='/tmp/nest-in'
readonly SCRIPTS_DIR="$TMP_WORK_DIR/scripts"
readonly CUSTOM_REQS_PATH="$TMP_WORK_DIR/custom-reqs"
readonly CONTEXT_DIR="$TMP_WORK_DIR/context"
readonly TARGET_FIRST_STEP_NAME='_FIRST_STEP'
readonly TARGET_LAST_STEP_NAME='_LAST_STEP'
readonly TARGET_CUSTOM_REQS_NAME='_CUSTOM_REQS'

readonly NEST_IN__CONTEXT_ORIGINAL_VARIABLES_PATH="$CONTEXT_DIR/original-variables"; export NEST_IN__CONTEXT_ORIGINAL_VARIABLES_PATH
readonly NEST_IN__CONTEXT_VARIABLES_PATH="$CONTEXT_DIR/variables"; export NEST_IN__CONTEXT_VARIABLES_PATH
readonly NEST_IN__CONTEXT_FUNCTIONS_PATH="$CONTEXT_DIR/functions"; export NEST_IN__CONTEXT_FUNCTIONS_PATH
readonly NEST_IN__CONTEXT_CURRENT_VARIABLES_PATH="$CONTEXT_DIR/current-variables"; export NEST_IN__CONTEXT_CURRENT_VARIABLES_PATH

#
# Globals

TWIGS_PATH=''
TWIGS_DESCRIPTOR=-1
ALL_TARGETS=()
REGULAR_TARGETS=()
FIRST_STEP=''
LAST_STEP=''
CUSTOM_REQS=''
INPUT_TARGETS=()

# do-the-work() { : "$@"; }
deal-with-scripts() { run-scripts "$@"; }

#
# Requirements

extract-value()
{
	local value=$1
	local line=$2

	line="${line#${value}=}"
	line="${line#\"*}"
	line="${line%*\"}"

	printf '%s' "$line"
}

gather-linux-info()
{
	if [ ! -r /etc/os-release ]
	then
		SYSTEM_INFO__LINUX_FAMILY=unknown
		SYSTEM_INFO__LINUX_DISTRIBUTION=unknown
		SYSTEM_INFO__OS_VERSION=unknown
		return
	fi

	local line=$(grep '^ID=' /etc/os-release)
	SYSTEM_INFO__LINUX_DISTRIBUTION=$(extract-value 'ID' "$line")

	line=$(grep '^ID_LIKE=' /etc/os-release)
	SYSTEM_INFO__LINUX_FAMILY=$(extract-value 'ID_LIKE' "$line")

	line=$(grep '^VERSION_ID=' /etc/os-release)
	SYSTEM_INFO__OS_VERSION=$(extract-value 'VERSION_ID' "$line")

	if [[ $SYSTEM_INFO__LINUX_FAMILY == *debian* ]] # Elementary OS stores ID_LIKE="ubuntu debian"
	then
		SYSTEM_INFO__LINUX_FAMILY='debian'
	elif [[ $SYSTEM_INFO__LINUX_FAMILY == *suse* ]] # OpenSuSE stores ID_LIKE="suse opensuse"
	then
		SYSTEM_INFO__LINUX_FAMILY='suse'
	elif [ -z "$SYSTEM_INFO__LINUX_FAMILY" ]
	then
		if [ -f /etc/arch-release ]
		then
			SYSTEM_INFO__LINUX_FAMILY='arch'
		elif [ -f /etc/debian_version ]
		then
			SYSTEM_INFO__LINUX_FAMILY='debian'
		elif [ -f /etc/redhat-release ]
		then
			SYSTEM_INFO__LINUX_FAMILY='redhat'
		fi
	fi

	if [[ $SYSTEM_INFO__LINUX_DISTRIBUTION == opensuse* ]] # OpenSUSE stores ID="opensuse-leap"
	then
		SYSTEM_INFO__LINUX_DISTRIBUTION=opensuse
	elif [ -z "$SYSTEM_INFO__LINUX_DISTRIBUTION" ]
	then
		if [[ $SYSTEM_INFO__LINUX_FAMILY == arch ]]
		then
			SYSTEM_INFO__LINUX_DISTRIBUTION=$(lsb_release -id --short | awk '{ print $1 }' | tr '[:upper:]' '[:lower:]')
		elif [[ $SYSTEM_INFO__LINUX_FAMILY == debian ]]
		then
			SYSTEM_INFO__LINUX_DISTRIBUTION=$(lsb_release -id --short | head -1 | tr '[:upper:]' '[:lower:]')
		elif [[ $SYSTEM_INFO__LINUX_FAMILY == redhat ]]
		then
			SYSTEM_INFO__LINUX_DISTRIBUTION=$(awk '{ print $1 }' /etc/redhat-release | tr '[:upper:]' '[:lower:]')
		fi
	fi

	# Tails stores VERSION="x.y.z"
	if [ -z "$SYSTEM_INFO__OS_VERSION" ]
	then
		line=$(grep '^VERSION=' /etc/os-release)
		local version=$(extract-value 'VERSION' "$line")
		if [[ $version =~ ^[0-9]+[0-9\.]*[0-9]+$ ]]
		then
			SYSTEM_INFO__OS_VERSION="$version"
		fi
	fi

	if [ -z "$SYSTEM_INFO__OS_VERSION" ]
	then
		if [[ $SYSTEM_INFO__LINUX_FAMILY == arch ]]
		then
			SYSTEM_INFO__OS_VERSION=$(lsb_release --release --short)
		elif [[ $SYSTEM_INFO__LINUX_FAMILY == debian ]]
		then
			SYSTEM_INFO__OS_VERSION=$(grep '^DISTRIB_RELEASE' /etc/lsb-release | awk -F= '{ print $2 }')
		elif [[ $SYSTEM_INFO__LINUX_FAMILY == redhat ]]
		then
			SYSTEM_INFO__OS_VERSION=$(awk '{ print $3 }' /etc/redhat-release)
		fi
	fi
}

gather-system-info()
{
	case "$OSTYPE" in
		darwin*)
			SYSTEM_INFO__OS=macos
			SYSTEM_INFO__LINUX_FAMILY=''
			SYSTEM_INFO__LINUX_DISTRIBUTION=''
			SYSTEM_INFO__OS_VERSION=$(sw_vers --productVersion)
			;;

		linux*)
			SYSTEM_INFO__OS='linux'
			gather-linux-info
			;;

		cygwin)
			SYSTEM_INFO__OS=cygwin
			SYSTEM_INFO__LINUX_FAMILY=''
			SYSTEM_INFO__LINUX_DISTRIBUTION=''
			SYSTEM_INFO__OS_VERSION=''
			;;

		msys)
			SYSTEM_INFO__OS=msys
			SYSTEM_INFO__LINUX_FAMILY=''
			SYSTEM_INFO__LINUX_DISTRIBUTION=''
			SYSTEM_INFO__OS_VERSION=''
			;;
	esac

	readonly \
		SYSTEM_INFO__OS \
		SYSTEM_INFO__LINUX_FAMILY \
		SYSTEM_INFO__LINUX_DISTRIBUTION \
		SYSTEM_INFO__OS_VERSION
}

print-system-info()
{
	printf 'os: "%s"\n' "$SYSTEM_INFO__OS"

	if [ -n "$SYSTEM_INFO__LINUX_FAMILY" ]
	then
		printf 'family: "%s"\n' "$SYSTEM_INFO__LINUX_FAMILY"
	fi

	if [ -n "$SYSTEM_INFO__LINUX_FAMILY" ]
	then
		printf 'distribution: "%s"\n' "$SYSTEM_INFO__LINUX_DISTRIBUTION"
	fi

	printf 'version: "%s"\n' "$SYSTEM_INFO__OS_VERSION"
}

os()
{
	local name=$1
	local version=$2

	[[ $SYSTEM_INFO__OS == $name ]] ||
	[[ $SYSTEM_INFO__LINUX_DISTRIBUTION == $name ]] &&

	if [ -n "$version" ]
	then
		versions-equal $SYSTEM_INFO__OS_VERSION $version
	fi
}

avail()
{
	local program=$1

	local type_of_object=$(type -t "$program")
	[[ $type_of_object == file ]] || [[ $type_of_object == function ]]
}

macos()
{
	local version=$1

	[[ $SYSTEM_INFO__OS == 'macos' ]] &&
	if [ -n "$version" ]
	then
		versions-equal $SYSTEM_INFO__OS_VERSION $version
	fi
}

linux()
{
	local family=$1
	local distribution=$2
	local version=$3

	[[ $SYSTEM_INFO__OS == 'linux' ]] &&
	if [ -n "$family" ]
	then
		[[ $SYSTEM_INFO__LINUX_FAMILY == $family ]]
	fi &&
	if [ -n "$distribution" ]
	then
		[[ $SYSTEM_INFO__LINUX_DISTRIBUTION == $distribution ]]
	fi &&
	if [ -n "$version" ]
	then
		versions-equal $SYSTEM_INFO__OS_VERSION $version
	fi
}

debian() { linux 'debian' "$@"; }
ubuntu() { debian 'ubuntu' "$@"; }
elementary() { debian 'elementary' "$@"; }
kali() { debian 'kali' "$@"; } # not tested yet
tails() { debian 'tails' "$@"; } # not tested yet

redhat() { linux 'redhat' "$@"; }
fedora() { redhat 'fedora' "$@"; }

arch() { linux 'arch' "$@"; }
manjaro() { arch 'manjaro' "$@"; }

suse() { linux 'suse' "$@"; }
opensuse() { suse 'opensuse' "$@"; }

cygwin() { [[ $SYSTEM_INFO__OS == 'cygwin' ]]; }

#
# Functions

parse-arguments()
{
	local arguments=("$@")

	local index
	for (( index = 0; index < $#; ++index ))
	do
		local argument="${arguments[$index]}"
		case "$argument" in
			'-d'|'--dependencies')
				do-the-work() { show-targets-with-dependencies "$@"; }
				;;

			'-n'|'--dry')
				deal-with-scripts() { cat-scripts "$@"; }
				;;

			'-i'|'--system-info')
				print-system-info
				exit
				;;

			'-h'|'--help')
				print-help
				exit
				;;

			'--')
				INPUT_TARGETS=("${arguments[@]:$index + 1}")
				break
				;;

			*)
				if [ -n "$TWIGS_PATH" ]
				then
					printf-error 'unknown argument %q' "$argument"
					exit 1
				fi

				TWIGS_PATH="${arguments[$index]}"
				;;
		esac
	done
}

validate-and-apply-options()
{
	if [ -z "$TWIGS_PATH" ]
	then
		TWIGS_DESCRIPTOR=0
	else
		TWIGS_DESCRIPTOR=3
		open-file $TWIGS_DESCRIPTOR "$TWIGS_PATH" >/dev/null 2>&1
		if [[ $? != 0 ]]
		then
			printf-error 'failed to open config file "%s"' "$TWIGS_PATH"
			return 1
		fi
	fi

	if ! declare -f do-the-work > /dev/null
	then
		do-the-work() { assemble-and-deal-with-nesting-scripts "$@"; }
	fi
}

open-file()
{
	local descriptor=$1
	local path=$2

	eval "exec $descriptor< \"$path\""
	if [[ $? != 0 ]]
	then
		return 1
	fi

	trap "exec $descriptor>&-" EXIT
}

FILE_READ_LINE_RETURN__LINE_NUMBER=0

FILE_PEEK_LINE_RETURN__LINE=''
FILE_PEEK_LINE_RETURN__PEEKED=false
file-peek-line()
{
	local descriptor=$1

	if $FILE_PEEK_LINE_RETURN__PEEKED
	then
		return
	fi

	read -u $descriptor -r FILE_PEEK_LINE_RETURN__LINE
	if [[ $? != 0 ]]
	then
		FILE_PEEK_LINE_RETURN__PEEKED=false
		return 1
	fi

	FILE_PEEK_LINE_RETURN__PEEKED=true
	(( ++FILE_READ_LINE_RETURN__LINE_NUMBER ))
}

FILE_READ_LINE_RETURN__LINE=''
file-read-line()
{
	local descriptor=$1

	if $FILE_PEEK_LINE_RETURN__PEEKED
	then
		FILE_READ_LINE_RETURN__LINE="$FILE_PEEK_LINE_RETURN__LINE"
		FILE_PEEK_LINE_RETURN__LINE=''
		FILE_PEEK_LINE_RETURN__PEEKED=false
	else
		read -u $descriptor -r FILE_READ_LINE_RETURN__LINE
		if [[ $? != 0 ]]
		then
			return 1
		fi

		FILE_PEEK_LINE_RETURN__LINE=''
		FILE_PEEK_LINE_RETURN__PEEKED=false
		(( ++FILE_READ_LINE_RETURN__LINE_NUMBER ))
	fi
}

next-non-empty-line()
{
	local descriptor=$1

	while true
	do
		if ! file-peek-line $descriptor
		then
			return
		fi

		if [ -n "$FILE_PEEK_LINE_RETURN__LINE" ]
		then
			break
		fi

		file-read-line $descriptor
	done
}

is-target-declaration()
{
	local line=$1

	# Example
	# target-name
	[[ $line =~ ^[[:alpha:]]+[[:alnum:]_\-]*[[:blank:]]*!?[[:blank:]]*$ ]] ||
	#            target-name...............             !

	# Example
	# target-name! / [requirement:specifier] [requirement] another-target and-another
	#                                                                               (                           |                                       |                   |                       )(                                       |                                                   |                               |                                  )
	[[ $line =~ ^[[:alpha:]]+[[:alnum:]_\-]*[[:blank:]]*!?[[:blank:]]*\/[[:blank:]]*([[:alpha:]]+[[:alnum:]_\-]*|\[[[:alpha:]_\-]+\:[[:alnum:]:_\.\-]+\]|\[[[:alpha:]_\-]+\]|\'[[:alnum:]_\.~/\-]+\')([[:blank:]]+[[:alpha:]]+[[:alnum:]_\-]*|[[:blank:]]+\[[[:alpha:]_\-]+\:[[:alnum:]:_\.\-]+\]|[[:blank:]]+\[[[:alpha:]_\-]+\]|[[:blank:]+\'[[:alnum:]_\.~/\-]+\')*[[:blank:]]*$ ]] ||
	#            target-name................            !              /             dependency-name............  [requirement.... :specifier........ ]  [requirement..... ]  'artifact............'              dependency-name............              [requirement.... :specifier......... ]              [requirement.... ]             'artifact............'

	[[ $line =~ ^(\.first|\.last)[[:blank:]]*$ ]] ||

	# Example + / [requirement:specifier] [requirement]
	#            (       |      )                          (                                       |                   )(                                                   |                               )
	[[ $line =~ ^(\.first|\.last)[[:blank:]]*\/[[:blank:]]*(\[[[:alpha:]_\-]+\:[[:alnum:]:_\.\-]+\]|\[[[:alpha:]_\-]+\])([[:blank:]]+\[[[:alpha:]_\-]+\:[[:alnum:]:_\.\-]+\]|[[:blank:]]+\[[[:alpha:]_\-]+\])*$ ]] ||
	#              .first  .last              /              [requirement.... :specifier......... ]  [requirement.... ]               [requirement.... :specifier......... ]              [requirement.... ]

	[[ $line =~ ^\.reqs[[:blank:]]*$ ]]
}

is-script-declaration()
{
	local line=$1

	[ -z "$line" ] || [[ $line =~ ^[[:blank:]]+.*$ ]]
}

EXTRACT_TARGET_RETURN__TARGET=''
extract-target()
{
	local line=$1

	line="${line%%/*}"
	line="${line%%!*}"
	EXTRACT_TARGET_RETURN__TARGET="${line%% *}"
}

readonly TARGET_TYPE_CODE__REGULAR=1
readonly TARGET_TYPE_CODE__FIRST_STEP=2
readonly TARGET_TYPE_CODE__LAST_STEP=3
readonly TARGET_TYPE_CODE__CUSTOM_REQS=4
readonly TARGET_TYPE_CODE__DEDICATED=5
target-type()
{
	if [[ $line =~ ^\.first[[:blank:]]* ]]
	then
		return $TARGET_TYPE_CODE__FIRST_STEP
	elif [[ $line =~ ^\.last[[:blank:]]* ]]
	then
		return $TARGET_TYPE_CODE__LAST_STEP
	elif [[ $line =~ ^\.reqs[[:blank:]]* ]]
	then
		return $TARGET_TYPE_CODE__CUSTOM_REQS
	elif [[ $line == *!* ]]
	then
		return $TARGET_TYPE_CODE__DEDICATED
	else
		return $TARGET_TYPE_CODE__REGULAR
	fi

}

EXTRACT_REQS_DEPS_ARTS_RETURN__REQUIREMENTS=()
EXTRACT_REQS_DEPS_ARTS_RETURN__DEPENDENCIES=()
EXTRACT_REQS_DEPS_ARTS_RETURN__ARTIFACTS=()
extract-reqs-deps-arts()
{
	local line=$1

	EXTRACT_REQS_DEPS_ARTS_RETURN__REQUIREMENTS=()
	EXTRACT_REQS_DEPS_ARTS_RETURN__DEPENDENCIES=()
	EXTRACT_REQS_DEPS_ARTS_RETURN__ARTIFACTS=()

	if [[ $line != */* ]]
	then
		return
	fi

	local old_IFS="$IFS"
	IFS=$' '

	local tokens=(${line#*/})
	for token in "${tokens[@]}"
	do
		case ${token:0:1} in
			\[)
				token=${token#[}
				token=${token%]}
				EXTRACT_REQS_DEPS_ARTS_RETURN__REQUIREMENTS+=("$token")
				;;

			\')
				token=${token#\'}
				token=${token%\'}
				EXTRACT_REQS_DEPS_ARTS_RETURN__ARTIFACTS+=("$token")
				;;

			*)
				EXTRACT_REQS_DEPS_ARTS_RETURN__DEPENDENCIES+=("$token")
		esac
	done

	IFS="$old_IFS"
}

array-contains-item()
{
	local item=$1
	local array=("${@:2}")

	local current
	for current in "${array[@]}"
	do
		if [[ $current == $item ]]
		then
			return 0
		fi
	done

	return 1
}

array-sort()
{
	local old_IFS="$IFS"
	IFS=$'\n'
	printf '%s\n' "$@" | sort
	IFS="$old_IFS"
}

normalize-target-name()
{
	local target=$1

	case "$target" in
		$TARGET_FIRST_STEP_NAME)
			printf '%s' '.first'
			;;

		$TARGET_LAST_STEP_NAME)
			printf '%s' '.last'
			;;

		*)
			printf '%s' "$target"
			;;
	esac
}

variable-name-from-target()
{
	local string=$1

	tr '-' '_' <<< "$string"
}

is-target-marked()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_marked="DB__MARKED_${variable_name}"
	[[ ${!target_marked} != '' ]] && ${!target_marked}
}

target-unmark()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_marked="DB__MARKED_${variable_name}"
	printf -v "$target_marked" false
}

target-mark()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_marked="DB__MARKED_${variable_name}"
	printf -v "$target_marked" true
}

targets-unmark()
{
	local targets=("$@")

	local target
	for target in "${targets[@]}"
	do
		target-unmark "$target"
	done
}

TARGET_DECLARATION_RETURN__DECLARATION=''
TARGET_DECLARATION_RETURN__LINE_NUMBER=''
target-declaration()
{
	local target=$1
	local variant=$2

	if [ -z "$variant" ]
	then
		variant=0
	fi

	local variable_name=$(variable-name-from-target "$target")
	eval "TARGET_DECLARATION_RETURN__DECLARATION=(\"\${DB__DECLARATIONS_${variable_name}[$variant]}\")"
	eval "TARGET_DECLARATION_RETURN__LINE_NUMBER=(\"\${DB__DECLARATION_LINE_NUMBERS_${variable_name}[$variant]}\")"
}

target-add-declaration()
{
	local target=$1
	local declaration=$2
	local line_number=$3

	local variable_name=$(variable-name-from-target "$target")
	eval "DB__DECLARATIONS_${variable_name}+=(\"$declaration\")"
	eval "DB__DECLARATION_LINE_NUMBERS_${variable_name}+=($line_number)"
}

target-use-declaration-variant()
{
	local target=$1
	local variant=$2

	target-declaration "$target" $variant
	local declaration="$TARGET_DECLARATION_RETURN__DECLARATION"
	local line_number=$TARGET_DECLARATION_RETURN__LINE_NUMBER

	local variable_name=$(variable-name-from-target "$target")
	eval "DB__DECLARATIONS_${variable_name}[0]=\"$declaration\""
	eval "DB__DECLARATION_LINE_NUMBERS_${variable_name}[0]=$line_number"
}

TARGET_VARIANT_COUNT_RETURN__COUNT=
target-variant-count()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	eval "TARGET_VARIANT_COUNT_RETURN__COUNT=\${#DB__DECLARATIONS_${variable_name}[@]}"

}

TARGET_REQUIREMENTS_RETURN__REQUIREMENTS=()
target-requirements()
{
	local target=$1
	local variant=$2

	if [ -z "$variant" ]
	then
		variant=0
	fi

	local variable_name=$(variable-name-from-target "$target")
	local requirements
	eval "requirements=(\"\${DB__REQUIREMENTS_${variable_name}[$variant]}\")"

	local old_IFS="$IFS"
	IFS=$' '
	TARGET_REQUIREMENTS_RETURN__REQUIREMENTS=(${requirements[@]})
	IFS="$old_IFS"
}

target-add-requirements()
{
	local target=$1
	local requirements=("${@:2}")

	local old_IFS="$IFS"
	IFS=$' '
	requirements="${requirements[@]}"
	IFS="$old_IFS"

	local target_variable_name=$(variable-name-from-target "$target")
	eval "DB__REQUIREMENTS_${target_variable_name}+=(\"$requirements\")"
}

target-requirements-resolved()
{
	local target=$1

	local target_variable_name=$(variable-name-from-target "$target")
	eval "\$DB__REQUIREMENTS_RESOLVED_${target_variable_name}"
}

target-set-requirements-resolved()
{
	local target=$1

	local target_variable_name=$(variable-name-from-target "$target")
	eval "DB__REQUIREMENTS_RESOLVED_${target_variable_name}=true"
}

target-set-requirements-unresolved()
{
	local target=$1

	local target_variable_name=$(variable-name-from-target "$target")
	eval "DB__REQUIREMENTS_RESOLVED_${target_variable_name}=false"
}

target-has-requirements-resolution-mark()
{
	local target=$1

	local target_variable_name=$(variable-name-from-target "$target")
	eval "[ -n \"\$DB__REQUIREMENTS_RESOLVED_${target_variable_name}\" ]"
}

TARGET_DEPENDENCIES_RETURN__DEPENDENCIES=()
target-dependencies()
{
	local target=$1
	local variant=$2

	if [ -z "$variant" ]
	then
		variant=0
	fi

	local variable_name=$(variable-name-from-target "$target")
	local dependencies
	eval "dependencies=(\"\${DB__DEPENDENCIES_${variable_name}[$variant]}\")"

	local old_IFS="$IFS"
	IFS=$' '
	TARGET_DEPENDENCIES_RETURN__DEPENDENCIES=(${dependencies[@]})
	IFS="$old_IFS"
}

target-dependencies-recursive-impl()
{
	local target=$1

	target-dependencies "$target"
	local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
	if [[ ${#dependencies[@]} == 0 ]]
	then
		return
	fi

	TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES+=("${dependencies[@]}")

	for dependency in "${dependencies[@]}"
	do
		target-dependencies-recursive-impl "$dependency"
	done
}

TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES=()
target-dependencies-recursive()
{
	local target=$1

	TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES=()

	target-dependencies-recursive-impl "$target"
	TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES=($(IFS=$'\n' sort <<< "${TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES[*]}" | uniq))
}

target-add-dependencies()
{
	local target=$1
	local dependencies=("${@:2}")

	local old_IFS="$IFS"
	IFS=$' '
	dependencies="${dependencies[@]}"
	IFS="$old_IFS"

	local target_variable_name=$(variable-name-from-target "$target")
	eval "DB__DEPENDENCIES_${target_variable_name}+=(\"$dependencies\")"
}

target-use-dependencies-variant()
{
	local target=$1
	local variant=$2

	local old_IFS="$IFS"
	IFS=$' '
	target-dependencies "$target" $variant
	local dependencies="${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}"
	IFS="$old_IFS"

	local target_variable_name=$(variable-name-from-target "$target")
	eval "DB__DEPENDENCIES_${target_variable_name}[0]=\"$dependencies\""
}

TARGET_ARTIFACTS_RETURN__ARTIFACTS=()
target-artifacts()
{
	local target=$1
	local variant=$2

	if [ -z "$variant" ]
	then
		variant=0
	fi

	local variable_name=$(variable-name-from-target "$target")
	local artifacts
	eval "artifacts=(\"\${DB__ARTIFACTS_${variable_name}[$variant]}\")"

	local old_IFS="$IFS"
	IFS=$' '
	TARGET_ARTIFACTS_RETURN__ARTIFACTS=(${artifacts[@]})
	IFS="$old_IFS"
}

target-add-artifacts()
{
	local target=$1
	local artifacts=("${@:2}")

	local old_IFS="$IFS"
	IFS=$' '
	artifacts="${artifacts[@]}"
	IFS="$old_IFS"

	local target_variable_name=$(variable-name-from-target "$target")
	eval "DB__ARTIFACTS_${target_variable_name}+=(\"$artifacts\")"
}

target-use-artifacts-variant()
{
	local target=$1
	local variant=$2

	local old_IFS="$IFS"
	IFS=$' '
	target-artifacts "$target" $variant
	local artifacts="${TARGET_ARTIFACTS_RETURN__ARTIFACTS[@]}"
	IFS="$old_IFS"

	local target_variable_name=$(variable-name-from-target "$target")
	eval "DB__ARTIFACTS_${target_variable_name}[0]=\"$artifacts\""
}

TARGET_SCRIPT_RETURN__SCRIPT=()
target-script()
{
	local target=$1
	local variant=$2

	if [ -z "$variant" ]
	then
		variant=0
	fi

	local variable_name=$(variable-name-from-target "$target")
	eval "TARGET_SCRIPT_RETURN__SCRIPT=(\"\${DB__SCRIPT_${variable_name}[$variant]}\")"
}

target-add-script()
{
	local target=$1
	local script=$2

	local variable_name=$(variable-name-from-target "$target")
	eval "DB__SCRIPT_${variable_name}+=(\"\$script\")"
}

target-use-script-variant()
{
	local target=$1
	local variant=$2

	local variable_name=$(variable-name-from-target "$target")
	local script
	eval "script=\"\${DB__SCRIPT_${variable_name}[$variant]}\""

	eval "DB__SCRIPT_${variable_name}[0]=\"\$script\""
}

target-use-variant()
{
	local target=$1
	local variant=$2

	target-use-declaration-variant "$target" $variant
	target-use-dependencies-variant "$target" $variant
	target-use-artifacts-variant "$target" $variant
	target-use-script-variant "$target" $variant
}

READ_TARGET_SCRIPT_RETURN__SCRIPT=''
read-target-script()
{
	local descriptor=$1

	READ_TARGET_SCRIPT_RETURN__SCRIPT=''

	while true
	do
		if ! file-peek-line $descriptor
		then
			return
		fi

		if ! is-script-declaration "$FILE_PEEK_LINE_RETURN__LINE"
		then
			break
		fi

		file-read-line $descriptor
		local line="$FILE_READ_LINE_RETURN__LINE"
		if [ -n "$line" ]
		then
			READ_TARGET_SCRIPT_RETURN__SCRIPT+="$line"$'\n'
		fi
	done
}

PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE=()
predicate-from-requirement()
{
	local requirement=$1

	PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE=()

	local old_IFS="$IFS"
	IFS=$':'

	PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE=(${requirement[@]})

	IFS="$old_IFS"
}

predicate-defined()
{
	local name=$1

	declare -f "$name" > /dev/null
}

readonly CHECK_REQUIREMENTS_CODE__UNKNOWN_NAME=255
CHECK_REQUIREMENTS_RETURN__VIOLATING_NAME=''
check-requirements()
{
	local requirements=("$@")

	for requirement in "${requirements[@]}"
	do
		predicate-from-requirement "$requirement"
		local predicate=("${PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE[@]}")
		if ! predicate-defined "${predicate[0]}"
		then
			CHECK_REQUIREMENTS_RETURN__VIOLATING_NAME="${predicate[0]}"
			return $CHECK_REQUIREMENTS_CODE__UNKNOWN_NAME
		fi

		if ! "${predicate[@]}"
		then
			return 1
		fi
	done
}

gather-twigs()
{
	local descriptor=$1

	local old_IFS="$IFS"
	IFS=

	while true
	do
		if ! next-non-empty-line $descriptor || ! file-peek-line $descriptor
		then
			break
		fi

		local line="$FILE_PEEK_LINE_RETURN__LINE"
		if ! is-target-declaration "$line"
		then
			printf-error 'bad declaration format\nline %d: %s' $FILE_READ_LINE_RETURN__LINE_NUMBER "$line"
			return 1
		fi

		file-read-line $descriptor
		line="$FILE_READ_LINE_RETURN__LINE"
		local line_number=$FILE_READ_LINE_RETURN__LINE_NUMBER
		target-type "$line"
		local target_type=$?

		local target
		if [[ $target_type == $TARGET_TYPE_CODE__FIRST_STEP ]]
		then
			FIRST_STEP="$TARGET_FIRST_STEP_NAME"
			target="$TARGET_FIRST_STEP_NAME"
		elif [[ $target_type == $TARGET_TYPE_CODE__LAST_STEP ]]
		then
			LAST_STEP="$TARGET_LAST_STEP_NAME"
			target="$TARGET_LAST_STEP_NAME"
		elif [[ $target_type == $TARGET_TYPE_CODE__CUSTOM_REQS ]]
		then
			CUSTOM_REQS="$TARGET_CUSTOM_REQS_NAME"
			target="$TARGET_CUSTOM_REQS_NAME"
		else
			extract-target "$line"
			target="$EXTRACT_TARGET_RETURN__TARGET"
		fi

		target-add-declaration "$target" "$line" $line_number

		extract-reqs-deps-arts "$line"
		local requirements=("${EXTRACT_REQS_DEPS_ARTS_RETURN__REQUIREMENTS[@]}")
		local dependencies=("${EXTRACT_REQS_DEPS_ARTS_RETURN__DEPENDENCIES[@]}")
		local artifacts=("${EXTRACT_REQS_DEPS_ARTS_RETURN__ARTIFACTS[@]}")
		target-add-requirements "$target" "${requirements[@]}"
		target-add-dependencies "$target" "${dependencies[@]}"
		target-add-artifacts "$target" "${artifacts[@]}"

		if [[ $target_type == $TARGET_TYPE_CODE__REGULAR ]] && ! array-contains-item "$target" "${REGULAR_TARGETS[@]}"
		then
			REGULAR_TARGETS+=("$target")
		fi

		if ! array-contains-item "$target" "${ALL_TARGETS[@]}"
		then
			ALL_TARGETS+=("$target")
		fi

		if ! file-peek-line $descriptor
		then
			break
		fi

		line="$FILE_PEEK_LINE_RETURN__LINE"
		if ! is-script-declaration "$line"
		then
			continue
		fi

		if ! read-target-script $descriptor
		then
			break
		fi

		local script="$READ_TARGET_SCRIPT_RETURN__SCRIPT"
		target-add-script "$target" "$script"
	done
	IFS="$old_IFS"

	targets-unmark "${ALL_TARGETS[@]}"
}

make-error-message-unknown-requirement()
{
	local target=$1
	local index=$2
	local requirement=$3

	target-declaration "$target" $index
	local line_number=$TARGET_DECLARATION_RETURN__LINE_NUMBER
	local declaration="$TARGET_DECLARATION_RETURN__DECLARATION"
	printf 'unknown requirement "%s" for "%s"\n\n' "$requirement" $(normalize-target-name "$target")
	printf '%s\nline %d: %s\n' "$(realpath -q "$TWIGS_PATH")" $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
}

make-error-message-none-requirements-fulfilled()
{
	local target=$1
	local dependency_path=("${@:2}")

	target=$(normalize-target-name "$target")
	printf 'none of "%s" variants have requirements met, while other targets depend on "%s"\n' "$target" "$target"

	printf '%s' "${dependency_path[0]}"
	printf ' -> %s' "${dependency_path[@]:1}"
	printf '\n'

	printf '\n%s\n' "$(realpath -q "$TWIGS_PATH")"
	local target
	for target in "${dependency_path[@]}"
	do
		target-declaration "$target"
		printf 'line %d: %s\n' $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
	done
}

make-error-message-duplicate-declarations()
{
	local target=$1
	local variants=("${@:2}")

	printf 'duplicate declarations for "%s"\n' $(normalize-target-name "$target")

	printf '\n%s\n' "$(realpath -q "$TWIGS_PATH")"
	local variant
	for variant in "${variants[@]}"
	do
		target-declaration "$target" $variant
		printf 'line %d: %s\n' $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
	done
}

make-error-message-unknown-dependency()
{
	local target=$1
	local dependency=$2

	target-declaration "$target"
	printf 'unknown dependency "%s" for "%s"\n\n%s\nline %d: %s\n' "$dependency" "$target" "$(realpath -q "$TWIGS_PATH")" $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
}

make-error-message-circular-dependency()
{
	local dependency_path=("$@")

	printf 'circular dependency found\n'
	printf '%s -> ' "${dependency_path[@]}"
	printf '%s\n' "${dependency_path[0]}"

	printf '\n%s\n' "$(realpath -q "$TWIGS_PATH")"
	local target
	for target in "${dependency_path[@]}"
	do
		target-declaration "$target"
		printf 'line %d: %s\n' $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
	done
}

TARGET_FIND_DUPLICATE_VARIANTS__INDEXES=()
target-find-duplicate-variants()
{
	local target=$1
	local variant=$2

	TARGET_FIND_DUPLICATE_VARIANTS__INDEXES=($variant)

	target-dependencies "$target" $variant
	local dependencies=$(array-sort "${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
	target-requirements "$target" $variant
	local requirements=$(array-sort "${TARGET_REQUIREMENTS_RETURN__REQUIREMENTS[@]}")

	target-variant-count "$target"
	local count=$TARGET_VARIANT_COUNT_RETURN__COUNT
	local duplicates=()
	local index
	for (( index = 0; index < count; ++index ))
	do
		if [[ $index == $variant ]]
		then
			continue
		fi

		target-dependencies "$target" $index
		local another_dependencies=$(array-sort "${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
		target-requirements "$target" $index
		local another_requirements=$(array-sort "${TARGET_REQUIREMENTS_RETURN__REQUIREMENTS[@]}")

		if [[ $dependencies == $another_dependencies && $requirements == $another_requirements ]]
		then
			TARGET_FIND_DUPLICATE_VARIANTS__INDEXES+=($index)
		fi
	done

	[[ ${#TARGET_FIND_DUPLICATE_VARIANTS__INDEXES[@]} == 1 ]]
}

TARGET_FIND_DUPLICATES_RETURN__INDEXES=()
target-find-duplicates()
{
	local target=$1

	TARGET_FIND_DUPLICATES_RETURN__INDEXES=()

	target-variant-count "$target"
	local count=$TARGET_VARIANT_COUNT_RETURN__COUNT
	local variant
	for (( variant = 0; variant < count; ++variant ))
	do
		if ! target-find-duplicate-variants "$target" $variant
		then
			TARGET_FIND_DUPLICATES_RETURN__INDEXES=("${TARGET_FIND_DUPLICATE_VARIANTS__INDEXES[@]}")
			return 1
		fi
	done
}

check-duplicates()
{
	local targets=("$@")

	for target in "${targets[@]}"
	do
		if ! target-find-duplicates "$target"
		then
			printf-error "$(make-error-message-duplicate-declarations "$target" "${TARGET_FIND_DUPLICATES_RETURN__INDEXES[@]}")"
			return 1
		fi
	done
}

make-custom-requirements-file()
{
	local path=$1

	if [ -z "$CUSTOM_REQS" ]
	then
		return
	fi

	target-script "$CUSTOM_REQS"
	local script="$TARGET_SCRIPT_RETURN__SCRIPT"

	rm -rf "$path"
	printf '%s' "$script" > "$path"
}

readonly RESOLVE_REQUIREMENTS_CODE__UNKNOWN_NAME=255
RESOLVE_REQUIREMENTS_RETURN__UNKNOWN_NAME=''
resolve-requirements()
{
	local requirements=("$@")

	for requirement in "${requirements[@]}"
	do
		predicate-from-requirement "$requirement"
		local predicate=("${PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE[@]}")
		if ! predicate-defined "${predicate[0]}"
		then
			RESOLVE_REQUIREMENTS_RETURN__UNKNOWN_NAME="${predicate[0]}"
			return $RESOLVE_REQUIREMENTS_CODE__UNKNOWN_NAME
		fi

		if ! "${predicate[@]}"
		then
			return 1
		fi
	done
}

resolve-requirements-for-target()
{
	local target=$1

	if target-has-requirements-resolution-mark "$target"
	then
		return
	fi

	target-variant-count "$target"
	local variant_count=$TARGET_VARIANT_COUNT_RETURN__COUNT
	local variant
	for (( variant = 0; variant < variant_count; ++variant ))
	do
		target-requirements "$target" $variant
		local requirements=("${TARGET_REQUIREMENTS_RETURN__REQUIREMENTS[@]}")
		if [[ ${#requirements[@]} == 0 ]]
		then
			target-use-variant "$target" $variant
			return
		fi

		resolve-requirements "${requirements[@]}"
		local retval=$?
		if [[ $retval == $RESOLVE_REQUIREMENTS_CODE__UNKNOWN_NAME ]]
		then
			printf-error '%s' "$(make-error-message-unknown-requirement "$target" $variant $RESOLVE_REQUIREMENTS_RETURN__UNKNOWN_NAME)"
			return 1
		fi

		if [[ $retval == 0 ]]
		then
			target-use-variant "$target" $variant
			target-set-requirements-resolved "$target"
			return
		fi
	done

	target-set-requirements-unresolved "$target"
}

resolve-requirements-and-verify-dependencies-for-target()
{
	local top_target=$1
	local target=$2
	local dependency_path=("${@:3}")

	if is-target-marked "$target"
	then
		return
	fi

	target-mark "$target"

	target-dependencies "$target"
	local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
	local dependency
	for dependency in "${dependencies[@]}"
	do
		target-declaration "$dependency"
		if [ -z "$TARGET_DECLARATION_RETURN__DECLARATION" ]
		then
			printf-error '%s' "$(make-error-message-unknown-dependency "$target" "$dependency")"
			return 1
		fi

		if ! resolve-requirements-for-target "$dependency"
		then
			return 1
		fi

		if ! target-requirements-resolved "$dependency"
		then
			printf-error '%s' "$(make-error-message-none-requirements-fulfilled "$dependency" "${dependency_path[@]}" "$dependency")"
			return 1
		fi

		if [[ $dependency == $top_target ]]
		then
			printf-error '%s' "$(make-error-message-circular-dependency "${dependency_path[@]}")"
			return 1
		fi

		if ! resolve-requirements-and-verify-dependencies-for-target "$top_target" "$dependency" "${dependency_path[@]}" "$dependency"
		then
			return 1
		fi
	done
}

RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_RETURN__RESOLVED_TARGETS=()
resolve-requirements-and-verify-dependencies()
{
	local targets=("$@")

	RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_RETURN__RESOLVED_TARGETS=()

	local target
	for target in "${targets[@]}"
	do
		target-declaration "$target"
		if [ -z "$TARGET_DECLARATION_RETURN__DECLARATION" ]
		then
			printf-error 'unknown target "%s"' "$target"
			return 1
		fi

		if ! resolve-requirements-for-target "$target"
		then
			return 1
		fi

		if target-requirements-resolved "$target"
		then
			RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_RETURN__RESOLVED_TARGETS+=("$target")
		else
			continue
		fi

		target-dependencies "$target"
		local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
		if ! resolve-requirements-and-verify-dependencies-for-target "$target" "$target" "$target"
		then
			return 1
		fi

		targets-unmark "${ALL_TARGETS[@]}"
	done
}

show-target-dependencies()
{
	local target=$1
	local indent=$2

	target-dependencies-recursive "$target"
	local dependencies=("${TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES[@]}")

	local dependency
	for dependency in "${dependencies[@]}"
	do
		printf "\n%s%s" "$indent" "$dependency"
	done

	printf '\n'
}

show-targets-with-dependencies()
{
	# local destination_dir=$1
	local targets=("${@:2}")

	local target="${targets[0]}"
	printf "\n${TS_TARGET_TITLE} = %s = ${TS_TARGET_TITLE_END}" "$target"
	show-target-dependencies "$target" '    '

	for target in "${targets[@]:1}"
	do
		printf "\n${TS_TARGET_TITLE} = %s = ${TS_TARGET_TITLE_END}" "$target"
		show-target-dependencies "$target" '    '
	done
}

file-start-script()
{
	local path=$1

	printf 'nest-in-load-context\nset -ex\n' > "$path"
	chmod u+x "$path"
}

file-end-script()
{
	local path=$1

	printf '{ set +ex; } 2> /dev/null\nnest-in-save-context\n' >> "$path"
}

file-append-string()
{
	local path=$1
	local line=$2

	printf '%s\n' "$line" >> "$path"
}

ARTIFACT_TYPE_CODE__PROGRAM=1
ARTIFACT_TYPE_CODE__FILE=2
ARTIFACT_TYPE_CODE__DIRECTORY=3
ARTIFACT_TYPE_CODE__UNKNOWN=255
artifact-type()
{
	local artifact=$1

	if [[ ${artifact: -1} == '/' ]]
	then
		return $ARTIFACT_TYPE_CODE__DIRECTORY
	elif [[ $artifact == */* ]]
	then
		return $ARTIFACT_TYPE_CODE__FILE
	else
		return $ARTIFACT_TYPE_CODE__PROGRAM
	fi

	return $ARTIFACT_TYPE_CODE__UNKNOWN
}

normalize-path()
{
	local path=$1

	if [[ ${path:0:1} == '~' ]]
	then
		path="${HOME}/${path#'~/'}"
	fi

	printf '%s' "$path"
}

ARTIFACT_EXISTS_RETURN__ARTIFACT=''
artifact-exists()
{
	local artifact=$1

	ARTIFACT_EXISTS_RETURN__ARTIFACT=''

	artifact-type "$artifact"
	case $? in
		$ARTIFACT_TYPE_CODE__PROGRAM)
			local path
			path=$(command -v "$artifact")
			local retval=$?
			ARTIFACT_EXISTS_RETURN__ARTIFACT="$path"
			return $retval
			;;

		$ARTIFACT_TYPE_CODE__FILE)
			artifact=$(normalize-path "$artifact")
			if ! [ -r "$artifact" ]
			then
				return 1
			fi

			ARTIFACT_EXISTS_RETURN__ARTIFACT=$(realpath -q "$artifact")
			;;

		$ARTIFACT_TYPE_CODE__DIRECTORY)
			artifact=$(normalize-path "$artifact")
			if ! [ -d "$artifact" ]
			then
				return 1
			fi

			ARTIFACT_EXISTS_RETURN__ARTIFACT=$(realpath -q "$artifact")
			;;

		$ARTIFACT_TYPE_CODE__UNKNOWN)
			;;
	esac
}

ARTIFACTS_EXIST_RETURN__ARTIFACTS=()
artifacts-exist()
{
	local artifacts=("$@")

	ARTIFACTS_EXIST_RETURN__ARTIFACTS=()

	if [[ ${#artifacts[@]} == 0 ]]
	then
		return 1
	fi

	local artifact
	for artifact in "${artifacts[@]}"
	do
		if ! artifact-exists "$artifact"
		then
			return 1
		fi

		ARTIFACTS_EXIST_RETURN__ARTIFACTS+=("$ARTIFACT_EXISTS_RETURN__ARTIFACT")
	done
}

make-message-all-artifacts-already-exist()
{
	local target=$1
	local artifacts=("${@:2}")

	printf 'All artifacts already exist:\n'
	local artifact
	for artifact in "${artifacts[@]}"
	do
		printf '  %s' "$artifact"
		artifact-type "$artifact"
		case $? in
			$ARTIFACT_TYPE_CODE__PROGRAM)
				printf $' -> %s\n' "$(which "$artifact")"
				;;

			$ARTIFACT_TYPE_CODE__DIRECTORY)
				local full_path="$(bash -c "realpath -q $artifact")/"
				if [[ $artifact != $full_path ]]
				then
					printf $' -> %s\n' "$full_path"
				else
					printf $'\n'
				fi
				;;

			$ARTIFACT_TYPE_CODE__FILE)
				local dir="$(dirname $artifact)"
				local name="$(basename $artifact)"
				local full_dir_path="$(bash -c "realpath -q $dir")"
				local full_path="$full_dir_path/$name"
				if [[ $artifact != $full_path ]]
				then
					printf $' -> %s\n' "$full_path"
				else
					printf $'\n'
				fi
				;;
		esac
	done
}

save-original-context()
{
	bash -c '(set -o posix; set)' > "$NEST_IN__CONTEXT_ORIGINAL_VARIABLES_PATH"
}

nest-in-save-context()
{
	(set -o posix; set) > "$NEST_IN__CONTEXT_CURRENT_VARIABLES_PATH"
	comm -2 -3 "$NEST_IN__CONTEXT_CURRENT_VARIABLES_PATH" "$NEST_IN__CONTEXT_ORIGINAL_VARIABLES_PATH" > "$NEST_IN__CONTEXT_VARIABLES_PATH"

	declare -f > "$NEST_IN__CONTEXT_FUNCTIONS_PATH"
}
export -f nest-in-save-context

nest-in-load-context()
{
	if [ -r "$NEST_IN__CONTEXT_VARIABLES_PATH" ]
	then
		source "$NEST_IN__CONTEXT_VARIABLES_PATH"
	fi

	if [ -r "$NEST_IN__CONTEXT_FUNCTIONS_PATH" ]
	then
		source "$NEST_IN__CONTEXT_FUNCTIONS_PATH"
	fi
}
export -f nest-in-load-context

ASSEMBLE_NESTING_SCRIPTS_RECURSIVE_RETURN__PATHS=()
assemble-nesting-scripts-recursive()
{
	local destination_dir=$1
	local targets=("${@:2}")

	local target
	for target in "${targets[@]}"
	do
		if is-target-marked "$target"
		then
			continue
		fi

		local path="$destination_dir/$target"

		target-artifacts "$target"
		local artifacts=("${TARGET_ARTIFACTS_RETURN__ARTIFACTS[@]}")
		if artifacts-exist "${artifacts[@]}"
		then
			file-append-string "$path.message" "$(make-message-all-artifacts-already-exist "$target" "${artifacts[@]}")"
			ASSEMBLE_NESTING_SCRIPTS_RECURSIVE_RETURN__PATHS+=("$path")
			target-mark "$target"
			continue
		fi

		target-dependencies "$target"
		local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
		assemble-nesting-scripts-recursive "$destination_dir" "${dependencies[@]}"

		target-script "$target"
		file-start-script "$path"
		file-append-string "$path" "$TARGET_SCRIPT_RETURN__SCRIPT"
		file-end-script "$path"

		ASSEMBLE_NESTING_SCRIPTS_RECURSIVE_RETURN__PATHS+=("$path")
		target-mark "$target"
	done
}

ASSEMBLE_NESTING_SCRIPTS_RETURN__PATHS=()
assemble-nesting-scripts()
{
	local destination_dir=$1
	local targets=("${@:2}")

	if target-requirements-resolved "$FIRST_STEP"
	then
		target-script "$FIRST_STEP"
		local script="$TARGET_SCRIPT_RETURN__SCRIPT"
		if [ -n "$script" ]
		then
			local script_path="$destination_dir/nest-in-first-step"
			file-start-script "$script_path"
			file-append-string "$script_path" "$script"
			file-end-script "$script_path"

			ASSEMBLE_NESTING_SCRIPTS_RETURN__PATHS+=("$script_path")
		fi
	fi

	assemble-nesting-scripts-recursive "$destination_dir" "${targets[@]}"
	ASSEMBLE_NESTING_SCRIPTS_RETURN__PATHS+=("${ASSEMBLE_NESTING_SCRIPTS_RECURSIVE_RETURN__PATHS[@]}")

	if target-requirements-resolved "$LAST_STEP"
	then
		target-script "$LAST_STEP"
		local script="$TARGET_SCRIPT_RETURN__SCRIPT"
		if [ -n "$script" ]
		then
			local script_path="$destination_dir/nest-in-last-step"
			file-start-script "$script_path"
			file-append-string "$script_path" "$script"
			file-end-script "$script_path"

			ASSEMBLE_NESTING_SCRIPTS_RETURN__PATHS+=("$script_path")
		fi
	fi
}

PRINT_CHOICE_PROMPT_RETURN__ANSWERS=()
print-choice-prompt()
{
	local prompt=$1
	local variants=("${@:2}")

	PRINT_CHOICE_PROMPT_RETURN__ANSWERS=()

	printf '%s\n' "$prompt"
	local index
	for (( index = 0; index < ${#variants[@]}; index += 2 ))
	do
		local variant="${variants[$index]}"
		local input="${variants[$index + 1]}"
		PRINT_CHOICE_PROMPT_RETURN__ANSWERS+=("$input")
		printf "  - %s [%s]\n" "$variant" "$input"
	done
}

is-acceptable-answer()
{
	local answer=$1
	local acceptable_answers=("${@:2}")

	local acceptable_answer
	for acceptable_answer in "${acceptable_answers[@]}"
	do
		if [[ $acceptable_answer == $answer* ]]
		then
			return
		fi
	done

	return 1
}

PROMPT_CHOICE_RETURN__ANSWER=''
prompt-choice()
{
	PROMPT_CHOICE_RETURN__ANSWER=''

	while true
	do
		print-choice-prompt "$@"
		read PROMPT_CHOICE_RETURN__ANSWER
		if is-acceptable-answer "$PROMPT_CHOICE_RETURN__ANSWER" "${PRINT_CHOICE_PROMPT_RETURN__ANSWERS[@]}"
		then
			break
		fi

		printf 'Unknown answer "%s".\n\n' "$PROMPT_CHOICE_RETURN__ANSWER"
	done
}

run-scripts()
{
	printf-message 'Nesting...'

	save-original-context

	local path
	for path in "$@"
	do
		local target="$(basename "$path")"
		printf-message "\n$TS_TARGET_TITLE = %s = $TS_TARGET_TITLE_END" "$target"

		if ! [ -r "$path" ] && [ -r "$path.message" ]
		then
			printf-message '%s\n' "$(cat "$path.message")"
			continue
		fi

		while true
		do
			"$path"
			if [[ $? == 0 ]]
			then
				break
			fi

			printf-error 'failed to nest target "%s". See output above for more information.' "$(basename "$path")"
			printf '\n'
			prompt-choice $'You can try to fix things using shell. After that you would be offered\nto restart current target or continue nesting the next one.\nDo you want to' 'open shell' 'o' 'stop nesting' 's'
			if [[ $PROMPT_CHOICE_RETURN__ANSWER == 's' ]]
			then
				printf-message 'Nesting stopped.'
				exit 1
			fi

			printf-message 'When done, exit shell'
			"$SHELL"

			prompt-choice 'Do you want to:' 'restart current target' 'r' 'continue nesting with the next target' 'c' 'stop nesting' 's'
			case $PROMPT_CHOICE_RETURN__ANSWER in
				'c')
					break
					;;

				'r')
					continue
					;;

				's')
					printf-message 'Nesting stopped.'
					exit 1
					;;
			esac
		done
	done
}

assemble-and-deal-with-nesting-scripts()
{
	local destination_dir=$1
	local targets=("${@:2}")

	printf-message 'Assembling nesting scripts...'
	assemble-nesting-scripts "$destination_dir" "${targets[@]}"
	local script_paths=("${ASSEMBLE_NESTING_SCRIPTS_RETURN__PATHS[@]}")

	deal-with-scripts "${script_paths[@]}"
}

cat-scripts()
{
	local path
	for path in "$@"
	do
		printf "\n$TS_TARGET_TITLE = %s = $TS_TARGET_TITLE_END\n" "$(basename "$path")"

		if ! [ -r "$path" ] && [ -r "$path.message" ]
		then
			printf-message '%s\n' "$(cat "$path.message")"
			continue
		fi

		cat "$path" | head -n $(( $(cat "$path" | wc -l) - 3 )) | tail -n +3
	done
}

#
# Main

gather-system-info

{ # Deal with arguments
	if ! parse-arguments "$@" || ! validate-and-apply-options
	then
		exit 1
	fi
}

{ # Do the work
	printf-message 'Gathering twigs...'
	if ! gather-twigs $TWIGS_DESCRIPTOR
	then
		exit 1
	fi

	if [[ ${#INPUT_TARGETS[@]} == 0 ]]
	then
		targets=("${REGULAR_TARGETS[@]}")
	else
		targets=("${INPUT_TARGETS[@]}")
	fi

	printf-message 'Checking twigs...'

	check-duplicates "$FIRST_STEP" "$LAST_STEP" "$CUSTOM_REQS"
	if [[ $? != 0 ]]
	then
		exit 1
	fi

	rm -rf "$TMP_WORK_DIR"
	mktemp -d "$TMP_WORK_DIR" > /dev/null
	mkdir -p "$CONTEXT_DIR" > /dev/null
	mkdir -p "$SCRIPTS_DIR" > /dev/null

	make-custom-requirements-file "$CUSTOM_REQS_PATH"
	if [ -r "$CUSTOM_REQS_PATH" ]
	then
		source "$CUSTOM_REQS_PATH"
		rm -f "$CUSTOM_REQS_PATH"
	fi

	resolve-requirements-for-target "$FIRST_STEP" &&
	resolve-requirements-for-target "$LAST_STEP"
	if [[ $? != 0 ]]
	then
		exit 1
	fi

	check-duplicates "${targets[@]}" &&
	resolve-requirements-and-verify-dependencies "${targets[@]}"
	if [[ $? != 0 ]]
	then
		exit 1
	fi

	targets=("${RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_RETURN__RESOLVED_TARGETS[@]}")
	do-the-work "$SCRIPTS_DIR" "${targets[@]}"

	rm -rf "$TMP_WORK_DIR"
}

