#!/bin/bash

#
# Essentials

readonly NEST_IN__SCRIPT_NAME=nest-in

readonly NEST_IN__TS_N='\e[0m'
readonly NEST_IN__TS_B='\e[1m'
readonly NEST_IN__TS_U='\e[4m'
readonly TS_ERROR='\e[0;31m'

NEST_IN__TS_ERR=''
NEST_IN__TS_ERR_END=''
if [ -t 1 ] && [ $(tput colors) \> 0 ]
then
	NEST_IN__TS_ERR="$TS_ERROR"
	NEST_IN__TS_ERR_END="$NEST_IN__TS_N"
fi

readonly NEST_IN__TS_ERR NEST_IN__TS_ERR_END

printf-stderr()
{
	printf "$@" >&2
}

printf-error()
{
	printf-stderr "$NEST_IN__TS_ERR$NEST_IN__SCRIPT_NAME error:$NEST_IN__TS_ERR_END "
	printf-stderr "$@"
	printf-stderr '\n'
}

printf-message()
{
	printf "$@"
	printf '\n'
}

printf-nest-in-message()
{
	printf "${NEST_IN__TS_U}$NEST_IN__SCRIPT_NAME${NEST_IN__TS_N}: "
	printf "$@"
	printf '\n'
}

print-help()
{
	printf \
"${NEST_IN__TS_B}USAGE${NEST_IN__TS_N}
  ${NEST_IN__TS_B}nest-in${NEST_IN__TS_N} [${NEST_IN__TS_U}-dsr${NEST_IN__TS_N}] [${NEST_IN__TS_U}targets...${NEST_IN__TS_N}] [${NEST_IN__TS_U}-k${NEST_IN__TS_N}] -- [${NEST_IN__TS_U}file${NEST_IN__TS_N}]

${NEST_IN__TS_B}OPTIONS${NEST_IN__TS_N}
  [${NEST_IN__TS_U}targets${NEST_IN__TS_N}...]  Specify targets to work with.
  ${NEST_IN__TS_B}-d${NEST_IN__TS_N}            Show dependencies for targets.
  ${NEST_IN__TS_B}-s${NEST_IN__TS_N}            Show scripts for targets.
  ${NEST_IN__TS_B}--${NEST_IN__TS_N} ${NEST_IN__TS_U}file${NEST_IN__TS_N}       Read nesting info from ${NEST_IN__TS_U}file${NEST_IN__TS_N}.
  ${NEST_IN__TS_B}--${NEST_IN__TS_N}            Read nesting info from from ${NEST_IN__TS_U}stdin${NEST_IN__TS_N}.
  ${NEST_IN__TS_B}-h${NEST_IN__TS_N}            Show this message.

${NEST_IN__TS_B}More information at${NEST_IN__TS_N} ${NEST_IN__TS_U}https://github.com/shrpnsld/nest-in${NEST_IN__TS_N}
"
}

#
# Constants

readonly NEST_IN__CONFIG_DIR_PATH="$HOME/.config/$NEST_IN__SCRIPT_NAME"
readonly NEST_IN__CONFIG_FILE_NAME='twigs.txt'
readonly NEST_IN__DEFAULT_TWIGS_PATH="$NEST_IN__CONFIG_DIR_PATH/$NEST_IN__CONFIG_FILE_NAME"

readonly NEST_IN__DECLARATION_SYNTAX_NOTE=\
"${NEST_IN__TS_U}Note${NEST_IN__TS_N}:
  - declaration should not be preceeded by any whitespace
  - only one target is allowed per declaration
  - target name can be followed by a '!'
  - target should be separated with its dependencies and requirements by '/'
  - each requirement shoud be listed inside '[' and ']'"

readonly NEST_IN__SCRIPT_SYNTAX_NOTE=\
"${NEST_IN__TS_U}Note${NEST_IN__TS_N}:
  - commands in script should be preceeded by any-sort of whitespace
  - script should end with a blank line"


#
# Options

NEST_IN__TWIGS_PATH="$NEST_IN__DEFAULT_TWIGS_PATH"
NEST_IN__TWIGS_DESCRIPTOR=-1
NEST_IN__INPUT_TARGETS=()

NEST_IN__DO_THE_WORK=:
do-the-work()
{
	"$NEST_IN__DO_THE_WORK" "$@"
}

#
# Built-in requirements

gather-system-info()
{
	case "$OSTYPE" in
		darwin*)
			NEST_IN__OS=macos
			NEST_IN__LINUX_BASED_ON=''
			NEST_IN__LINUX_DISTRIBUTION=''
			NEST_IN__OS_VERSION=$(sw_vers --productVersion)
			;;

		linux-gnu*)
			if [ -f /etc/debian_version ]
			then
				NEST_IN__OS='linux'
				NEST_IN__LINUX_BASED_ON='debian'
				NEST_IN__LINUX_DISTRIBUTION=$(lsb_release -id --short | tr '[:upper:]' '[:lower:]')
				NEST_IN__OS_VERSION=`cat /etc/lsb-release | grep '^DISTRIB_RELEASE' | awk -F=  '{ print $2 }'`
			#elif [ -f /etc/... ]
			#	...
			#then
			else
				NEST_IN__OS=unknown
				NEST_IN__LINUX_BASED_ON=unknown
				NEST_IN__LINUX_DISTRIBUTION=unknown
				NEST_IN__OS_VERSION=unknown
			fi
			;;

		cygwin)
			NEST_IN__OS=cygwin
			NEST_IN__LINUX_BASED_ON=''
			NEST_IN__LIINUX_DISTRIBUTION=''
			NEST_IN__OS_VERSION=''
			;;

		msys)
			NEST_IN__OS=msys
			NEST_IN__LINUX_BASED_ON=''
			NEST_IN__LINUX_DISTRIBUTION=''
			NEST_IN__OS_VERSION=''
			;;
	esac

	readonly \
		NEST_IN__OS \
		NEST_IN__LINUX_BASED_ON \
		NEST_IN__LINUX_DISTRIBUTION \
		NEST_IN__OS_VERSION
}

is-callable()
{
	local program=$1

	local type_of_object=$(type -tp "$program")
	[[ $type_of_object == file ]] || [[ $type_of_object == function ]]
}

macos()
{
	local version=$1

	[[ $NEST_IN__OS == 'macos' ]] &&
	if [ -n "$version" ]
	then
		[[ $NEST_IN__OS_VERSION == $version* ]]
	fi
}

linux()
{
	local based_on=$1
	local distribution=$2
	local version=$3

	[[ $NEST_IN__OS == 'linux' ]] &&
	if [ -n "$based_on" ]
	then
		[[ $NEST_IN__LINUX_BASED_ON == $based_on ]]
	fi &&
	if [ -n "$distribution" ]
	then
		[[ $NEST_IN__LINUX_DISTRIBUTION == $distribution ]]
	fi &&
	if [ -n "$version" ]
	then
		[[ $NEST_IN__OS_VERSION == $version* ]]
	fi
}

debian()
{
	[[ $NEST_IN__LINUX_DISTRIBUTION == 'debian' ]]
}

ubuntu()
{
	local version=$1

	[[ $NEST_IN__OS == 'ubuntu' ]] &&
	if [ -n "$version" ]
	then
		[[ $NEST_IN__OS_VERSION == $version* ]]
	fi
}

elementary()
{
	local version=$1

	[[ $NEST_IN__OS == 'elementary' ]] &&
	if [ -n "$version" ]
	then
		[[ $NEST_IN__OS_VERSION == $version* ]]
	fi
}

cygwin()
{
	[[ $NEST_IN__OS == 'cygwin' ]]
}

has-apt()
{
	is-callable apt
}

has-pacman()
{
	is-callable packman
}

has-nix()
{
	is-callable nix
}

has-yum()
{
	is-callable yum
}

#
# Functions

readonly PARAMETER_TYPE_OPTION=1
readonly PARAMETER_TYPE_TARGET=2
readonly PARAMETER_TYPE_DELIMITER=3
readonly PARAMETER_TYPE_BAD=255
PARAMETER_TYPE_RETURN__PARAMETER=''
parameter-type()
{
	local string=$1

	if [ "${string:0:3}" == '--' ] && [ "${#string}" == 2 ]
	then
		return $PARAMETER_TYPE_DELIMITER
	fi

	if [ "${string:0:1}" == '-' ]
	then
		PARAMETER_TYPE_RETURN__PARAMETER="${string#-}"
		return $PARAMETER_TYPE_OPTION
	fi

	if [[ $string =~ ^[a-zA-Z]+[a-zA-Z0-9_\-]*$ ]]
	then
		PARAMETER_TYPE_RETURN__PARAMETER="$string"
		return $PARAMETER_TYPE_TARGET
	fi

	return $PARAMETER_TYPE_BAD
}

PARSE_OPTION_UNKNOWN_OPTION=255
parse-option()
{
	local option=$1
	local value=$2

	case "$option" in
		d)
			NEST_IN__DO_THE_WORK=show-dependencies
			;;

		s)
			NEST_IN__DO_THE_WORK=show-scripts
			;;

		h)
			print-help
			exit
			;;

		*)
			return $PARSE_OPTION_UNKNOWN_OPTION
			;;
	esac
}

parse-arguments()
{
	local parameters=("$@")

	local parameter_index
	for (( parameter_index = 0; parameter_index < ${#parameters[@]}; ++parameter_index ))
	do
		local parameter
		parameter-type "${parameters[$parameter_index]}"
		local parameter_type=$?
		parameter="$PARAMETER_TYPE_RETURN__PARAMETER"
		case $parameter_type in
			$PARAMETER_TYPE_OPTION)
				local value="${parameters[$parameter_index + 1]}"
				local option_index
				for (( option_index = 0; option_index < ${#parameter}; ++option_index ))
				do
					local option="${parameter:$option_index:1}"
					parse-option "$option" "$value"
					local retval=$?
					case $retval in
						$PARSE_OPTION_UNKNOWN_OPTION)
							printf-error 'unknown option "%s"' "$option"
							return 1
							;;

						*)
							(( parameter_index += retval ))
							: # so the result of arithmetic above does not considered as a result of case-clause execution
							;;
					esac
				done

				continue
				;;

			$PARAMETER_TYPE_TARGET)
				NEST_IN__INPUT_TARGETS+=("$parameter")
				;;

			$PARAMETER_TYPE_DELIMITER)
				(( ++parameter_index ))
				NEST_IN__TWIGS_PATH="${parameters[$parameter_index]}"
				break
				;;

			$PARAMETER_TYPE_BAD)
				printf-error 'bad parameter format "%s"' "$parameter"
				return 1
				;;
		esac
	done
}

max-number()
{
	local first=$1
	local second=$2

	if [[ ${#first} > ${#second} ]]
	then
		return ${#first}
	else
		return ${#second}
	fi
}

open-twigs-file()
{
	local path=$1

	exec 3< "$path"
}

validate-and-apply-options()
{
	if [ -z "$NEST_IN__TWIGS_PATH" ]
	then
		NEST_IN__TWIGS_DESCRIPTOR=0
	else
		open-twigs-file "$NEST_IN__TWIGS_PATH" >/dev/null 2>&1
		if [ $? != 0 ]
		then
			printf-error 'failed to open config file "%s"' "$NEST_IN__TWIGS_PATH"
		fi

		NEST_IN__TWIGS_DESCRIPTOR=3
	fi

	if [ "$NEST_IN__DO_THE_WORK" == : ]
	then
		NEST_IN__DO_THE_WORK=start-nesting
	fi
}

is-target-declaration()
{
	local line=$1

	# Example
	# target-name
	[[ $line =~ ^[[:alpha:]]+[[:alnum:]_\-]*[[:blank:]]*!?[[:blank:]]*$ ]] ||
	#            target-name...............             !

	# Example
	# target-name / dependency-name [condition:value] [condition]
	#                                                     (                                       |                                                  |                               )
	[[ $line =~ ^[[:alpha:]]+[[:alnum:]_\-]*[[:blank:]]*!?[[:blank:]]*\/([[:blank:]]+[[:alpha:]]+[[:alnum:]_\-]*|[[:blank:]]+\[[[:alpha:]_\-]+\:[[:alnum:]_\.\-]+\]|[[:blank:]]+\[[[:alpha:]_\-]+\])+[[:blank:]]*$ ]]
	#            target-name................            !              /             dependency-name............              [requirement.... :value..........]                 [requirement.... ]
}

is-script-declaration()
{
	local line=$1

	[[ $line =~ ^[[:blank:]]+[^[:blank:]]+.*$ ]]
}

EXTRACT_TARGET_RETURN__TARGET=''
EXTRACT_TARGET_RETURN__IS_DESIGNATED=false
extract-target()
{
	local line=$1

	[[ $line == *!* ]]
	EXTRACT_TARGET_RETURN__IS_DESIGNATED=$?

	line="${line%%!*}"
	EXTRACT_TARGET_RETURN__TARGET="${line%% *}"
}

EXTRACT_REQS_AND_DEPS_RETURN__REQUIREMENTS=()
EXTRACT_REQS_AND_DEPS_RETURN__DEPENDENCIES=()
extract-reqs-and-deps()
{
	local line=$1

	EXTRACT_REQS_AND_DEPS_RETURN__REQUIREMENTS=()
	EXTRACT_REQS_AND_DEPS_RETURN__DEPENDENCIES=()

	if [[ $line != */* ]]
	then
		return
	fi

	line=${line#*/}

	local old_IFS="$IFS"
	IFS=$' '

	local tokens=(${line#*/})
	for token in "${tokens[@]}"
	do
		if [ "${token:0:1}" == '[' ]
		then
			token=${token#[}
			token=${token%]}
			EXTRACT_REQS_AND_DEPS_RETURN__REQUIREMENTS+=("$token")
		else
			EXTRACT_REQS_AND_DEPS_RETURN__DEPENDENCIES+=("$token")
		fi
	done

	IFS="$old_IFS"
}

TRIM_STRING_RETURN__STRING=''
trim-string()
{
	local string=$1

	TRIM_STRING_RETURN__STRING=''

    string="${string#"${string%%[![:space:]]*}"}"
    string="${string%"${string##*[![:space:]]}"}"
	TRIM_STRING_RETURN__STRING="$string"
}

array-contains-item()
{
	local item=$1
	local array=("${@:2}")

	local current
	for current in ${array[@]}
	do
		if [ "$current" == "$item" ]
		then
			return 0
		fi
	done

	return 1
}

variable-name-from-target()
{
	local string=$1

	tr '-' '_' <<< "$string"
}

is-target-marked()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_marked="NEST_IN__MARKED_${variable_name}"
	[[ ${!target_marked} != '' ]] && ${!target_marked}
}

unmark-target()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_marked="NEST_IN__MARKED_${variable_name}"
	printf -v "$target_marked" false
}

mark-target()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_marked="NEST_IN__MARKED_${variable_name}"
	printf -v "$target_marked" true
}

unmark-targets()
{
	local targets=("$@")

	for target in "${targets[@]}"
	do
		unmark-target "$target"
	done
}

TARGET_DECLARATION_RETURN__DECLARATION=''
TARGET_DECLARATION_RETURN__LINE_NUMBER=''
target-declaration()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	eval "TARGET_DECLARATION_RETURN__DECLARATION=(\"\$NEST_IN__DECLARATION_${variable_name}\")"
	eval "TARGET_DECLARATION_RETURN__LINE_NUMBER=(\"\$NEST_IN__DECLARATION_LINE_NUMBER_${variable_name}\")"
}

set-target-declaration()
{
	local target=$1
	local declaration=$2
	local line_number=$3

	local variable_name=$(variable-name-from-target "$target")
	printf -v "NEST_IN__DECLARATION_${variable_name}" '%s' "$declaration"
	printf -v "NEST_IN__DECLARATION_LINE_NUMBER_${variable_name}" '%s' "$line_number"
}

TARGET_DEPENDENCIES_RETURN__DEPENDENCIES=()
target-dependencies()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	eval "TARGET_DEPENDENCIES_RETURN__DEPENDENCIES=(\"\${NEST_IN__DEPENDENCIES_${variable_name}[@]}\")"
}

target-dependencies-recursive()
{
	local target=$1

	target-dependencies "$target"
	local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
	if [[ ${#dependencies[@]} == 0 ]]
	then
		return
	fi

	printf '  %s\n' "${dependencies[@]}"
	for dependency in "${dependencies[@]}"
	do
		target-dependencies-recursive "$dependency"
	done
}

set-target-dependencies()
{
	local target=$1

	local target_variable_name=$(variable-name-from-target "$target")
	eval "NEST_IN__DEPENDENCIES_${target_variable_name}=(${dependencies[@]})"
}

target-has-requirements()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local has_requirements="NEST_IN__HAS_REQUIREMENTS_${variable_name}"
	[[ ${!has_requirements} != '' ]] && [[ ${!has_requirements} == 0 ]]
}

set-target-has-requirements()
{
	local target=$1
	local value=$2

	local variable_name=$(variable-name-from-target "$target")
	local has_requirements="NEST_IN__HAS_REQUIREMENTS_${variable_name}"
	printf -v "$has_requirements" '%s' $value
}

TARGET_SCRIPT_RETURN__SCRIPT=()
target-script()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	eval "TARGET_SCRIPT_RETURN__SCRIPT=(\"\${NEST_IN__SCRIPT_${variable_name}[@]}\")"
}

set-target-script()
{
	local target=$1
	local script=("${@:2}")

	local variable_name=$(variable-name-from-target "$target")
	eval "NEST_IN__SCRIPT_${variable_name}=(\"\${script[@]}\")"
}

FILE_READ_LINE_RETURN__LINE_NUMBER=0

FILE_PEEK_LINE_RETURN__LINE=''
FILE_PEEK_LINE_RETURN__PEEKED=false
file-peek-line()
{
	local descriptor=$1

	if ! $FILE_PEEK_LINE_RETURN__PEEKED
	then
		read -u $descriptor -r FILE_PEEK_LINE_RETURN__LINE
		if [ $? != 0 ]
		then
			FILE_PEEK_LINE_RETURN__PEEKED=false
			return 1
		fi

		FILE_PEEK_LINE_RETURN__PEEKED=true
		(( ++FILE_READ_LINE_RETURN__LINE_NUMBER ))
	fi
}

FILE_READ_LINE_RETURN__LINE=''
file-read-line()
{
	local descriptor=$1

	if $FILE_PEEK_LINE_RETURN__PEEKED
	then
		FILE_READ_LINE_RETURN__LINE="$FILE_PEEK_LINE_RETURN__LINE"
		FILE_PEEK_LINE_RETURN__LINE=''
		FILE_PEEK_LINE_RETURN__PEEKED=false
	else
		read -u $descriptor -r FILE_READ_LINE_RETURN__LINE
		if [ $? != 0 ]
		then
			return 1
		fi

		FILE_PEEK_LINE_RETURN__LINE=''
		FILE_PEEK_LINE_RETURN__PEEKED=false
		(( ++FILE_READ_LINE_RETURN__LINE_NUMBER ))
	fi
}

next-non-empty-line()
{
	local descriptor=$1

	while true
	do
		file-peek-line $descriptor
		if [ $? != 0 ]
		then
			return 1
		fi

		if [ -n "$FILE_PEEK_LINE_RETURN__LINE" ]
		then
			break
		fi

		file-read-line $descriptor
	done
}

skip-script-declaration()
{
	local descriptor=$1

	while true
	do
		file-peek-line $descriptor
		if [ $? != 0 ]
		then
			return 1
		fi

		if ! is-script-declaration "$FILE_PEEK_LINE_RETURN__LINE"
		then
			break
		fi

		file-read-line $descriptor
	done
}

readonly READ_TARGET_SCRIPT_CODE__BAD_SYNTAX=1
READ_TARGET_SCRIPT_RETURN__SCRIPT=()
read-target-script()
{
	local descriptor=$1

	READ_TARGET_SCRIPT_RETURN__SCRIPT=()

	while true
	do
		file-read-line $descriptor
		if [ $? != 0 ] || [ -z "$FILE_READ_LINE_RETURN__LINE" ]
		then
			return
		fi

		local line="$FILE_READ_LINE_RETURN__LINE"
		trim-string "$line"
		READ_TARGET_SCRIPT_RETURN__SCRIPT+=("$TRIM_STRING_RETURN__STRING")

		if ! is-script-declaration "$line"
		then
			return $READ_TARGET_SCRIPT_CODE__BAD_SYNTAX
		fi
	done
}

PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE=()
predicate-from-requirement()
{
	local requirement=$1

	PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE=()

	local old_IFS="$IFS"
	IFS=$':'

	PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE=(${requirement[@]})

	IFS="$old_IFS"
}

predicate-defined()
{
	local name=$1

	declare -f "$name" > /dev/null
}

readonly CHECK_REQUIREMENTS_CODE__UNKNOWN_NAME=255
CHECK_REQUIREMENTS_RETURN__VIOLATING_NAME=''
check-requirements()
{
	local requirements=("$@")

	for requirement in "${requirements[@]}"
	do
		predicate-from-requirement "$requirement"
		local predicate=("${PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE[@]}")
		if ! predicate-defined "${predicate[0]}"
		then
			CHECK_REQUIREMENTS_RETURN__VIOLATING_NAME="${predicate[0]}"
			return $CHECK_REQUIREMENTS_CODE__UNKNOWN_NAME
		fi

		if ! "${predicate[@]}"
		then
			return 1
		fi
	done
}

GATHER_TWIGS_RETURN__TARGETS=()
GATHER_TWIGS_RETURN__DESIGNATED_TARGETS=()
gather-twigs()
{
	local descriptor=$1

	GATHER_TWIGS_RETURN__TARGETS=()
	GATHER_TWIGS_RETURN__DESIGNATED_TARGETS=()

	local old_IFS="$IFS"
	IFS=

	while true
	do
		next-non-empty-line $descriptor &&
		file-peek-line $descriptor
		if [ $? != 0 ]
		then
			break
		fi

		local line="$FILE_PEEK_LINE_RETURN__LINE"
		if ! is-target-declaration "$line"
		then
			printf-error 'bad declaration format\n> %s %d| %s\n\n'"$NEST_IN__DECLARATION_SYNTAX_NOTE" \
				"$NEST_IN__TWIGS_PATH" $FILE_READ_LINE_RETURN__LINE_NUMBER "$line"
			return 1
		fi

		file-read-line $descriptor
		line="$FILE_READ_LINE_RETURN__LINE"
		extract-target "$line"
		local target="$EXTRACT_TARGET_RETURN__TARGET"
		local is_explicit=$EXTRACT_TARGET_RETURN__IS_DESIGNATED

		extract-reqs-and-deps "$line"
		local dependencies=("${EXTRACT_REQS_AND_DEPS_RETURN__DEPENDENCIES[@]}")
		local requirements=("${EXTRACT_REQS_AND_DEPS_RETURN__REQUIREMENTS[@]}")

		check-requirements "${requirements[@]}"
		local requirements_fulfilled=$?
		if [ $requirements_fulfilled == $CHECK_REQUIREMENTS_CODE__UNKNOWN_NAME ]
		then
			printf-error 'unknown requirement "%s" for "%s"\n> %s %d| %s' \
				"$CHECK_REQUIREMENTS_RETURN__VIOLATING_NAME" "$target" \
				"$NEST_IN__TWIGS_PATH" $FILE_READ_LINE_RETURN__LINE_NUMBER "$line"
			return 1
		fi

		if [ $requirements_fulfilled != 0 ]
		then
			skip-script-declaration $descriptor
			if [ $? != 0 ]
			then
				break
			fi

			continue
		fi

		if is-target-marked "$target"
		then
			if target-has-requirements "$target" && [[ ${#requirements[@]} > 0 ]]
			then
				target-declaration "$target"
				local declaration="$TARGET_DECLARATION_RETURN__DECLARATION"
				local line_number="$TARGET_DECLARATION_RETURN__LINE_NUMBER"
				max-number $FILE_READ_LINE_RETURN__LINE_NUMBER $line_number
				local width=$?
				printf-error "several declarations of \"%s\" have requirements fulfilled\n> %s %${width}d| %s\n> %s %${width}d| %s" \
					"$target" \
					"$NEST_IN__TWIGS_PATH" $line_number "$declaration" \
					"$NEST_IN__TWIGS_PATH" $FILE_READ_LINE_RETURN__LINE_NUMBER "$line"
				return 1
			fi

			if ! target-has-requirements "$target" && [[ ${#requirements[@]} == 0 ]]
			then
				target-declaration "$target"
				local declaration="$TARGET_DECLARATION_RETURN__DECLARATION"
				local line_number="$TARGET_DECLARATION_RETURN__LINE_NUMBER"
				max-number $FILE_READ_LINE_RETURN__LINE_NUMBER $line_number
				local width=$?
				printf-error "duplicate declarations for \"%s\"\n> %s %${width}d| %s\n> %s %${width}d| %s" \
					"$target" \
					"$NEST_IN__TWIGS_PATH" $line_number "$declaration" \
					"$NEST_IN__TWIGS_PATH" $FILE_READ_LINE_RETURN__LINE_NUMBER "$line"
				return 1
			fi

			if target-has-requirements "$target" && [[ ${#requirements[@]} == 0 ]]
			then
				skip-script-declaration $descriptor
				if [ $? != 0 ]
				then
					break
				fi

				continue
			fi
		fi

		set-target-dependencies "$target" "$dependencies"
		[[ ${#requirements[@]} > 0 ]]
		set-target-has-requirements "$target" $?

		set-target-declaration "$target" "$line" $FILE_READ_LINE_RETURN__LINE_NUMBER

		if [ $is_explicit == 0 ]
		then
			GATHER_TWIGS_RETURN__DESIGNATED_TARGETS+=("$target")
		else
			GATHER_TWIGS_RETURN__TARGETS+=("$target")
		fi
		mark-target "$target"

		file-peek-line $descriptor
		if [ $? != 0 ]
		then
			break
		fi

		line="$FILE_PEEK_LINE_RETURN__LINE"
		if ! is-script-declaration "$line"
		then
			continue
		fi

		read-target-script $descriptor
		local script=("${READ_TARGET_SCRIPT_RETURN__SCRIPT[@]}")
		if [ $? == $READ_TARGET_SCRIPT_CODE__BAD_SYNTAX ]
		then
			printf-error 'bad script format for "%s":' "$target"
			printf-stderr '%s\n' "${script[@]}"
			printf-stderr "\n$NEST_IN__SCRIPT_SYNTAX_NOTE"
			return 1
		fi

		set-target-script "$target" "${script[@]}"
	done
	IFS="$old_IFS"

	unmark-targets "${GATHER_TWIGS_RETURN__TARGETS[@]}" "${GATHER_TWIGS_RETURN__DESIGNATED_TARGETS[@]}"
}

check-all-targets-exist()
{
	local targets=("$@")

	local any_errors=false
	local target
	for target in "${targets[@]}"
	do
		target-dependencies "$target"
		local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
		for dependency in "${dependencies[@]}"
		do
			if ! array-contains-item "$dependency" "${targets[@]}"
			then
				printf-error 'unknown dependency "%s" for "%s"; or not all requirements were fulfilled for "%s"' \
					"$dependency" "$target" "$dependency"
				any_errors=true
			fi
		done
	done

	! $any_errors
}

FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH=''
find-circular-dependencies-impl()
{
	local target_to_depend=$1
	local targets=("${@:2}")

	if array-contains-item "$target_to_depend" "${targets[@]}"
	then
		FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH="$target_to_depend"
		return 0
	fi

	local target
	for target in "${targets[@]}"
	do
		if is-target-marked "$target"
		then
			continue
		fi

		mark-target "$target"

		target-dependencies "$target"
		local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
		find-circular-dependencies-impl "$target_to_depend" "${dependencies[@]}"
		if [ $? == 0 ]
		then
			FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH="$target -> $FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH"
			return 0
		fi
	done

	return 1
}

find-circular-dependencies()
{
	local target=$1

	target-dependencies "$target"
	local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
	find-circular-dependencies-impl "$target" "${dependencies[@]}"
	local retval=$?
	FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH="$target -> $FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH"
	return $retval
}

check-theres-no-circular-dependencies()
{
	local targets=("$@")

	local target
	for target in "${targets[@]}"
	do
		if find-circular-dependencies "$target"
		then
			printf-error 'circular dependency was found: %s' "$FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH"
			return 1
		fi

		unmark-targets "${targets[@]}"
	done
}

check-input-targets-exist()
{
	local gathered_targets=("$@")

	for target in "${NEST_IN__INPUT_TARGETS[@]}"
	do
		if ! array-contains-item "$target" "${gathered_targets[@]}"
		then
			printf-error 'unkown target "%s" in arguments' "$target"
			return 1
		fi
	done
}

show-dependencies()
{
	local targets=("$@")

	local target="${targets[0]}"
	printf "${NEST_IN__TS_U}%s${NEST_IN__TS_N}\n" "$target"
	target-dependencies-recursive "$target" | sort | uniq

	for target in "${targets[@]:1}"
	do
		printf '\n'
		printf "${NEST_IN__TS_U}%s${NEST_IN__TS_N}\n" "$target"
		target-dependencies-recursive "$target" | sort | uniq
	done
}

show-scripts()
{
	local targets=("$@")

	local target="${targets[0]}"
	printf "${NEST_IN__TS_U}%s${NEST_IN__TS_N}\n" "$target"

	target-script "$target"
	local script=("${TARGET_SCRIPT_RETURN__SCRIPT[@]}")
	printf '  %s\n' "${script[@]}"

	for target in "${targets[@]:1}"
	do
		printf '\n'
		printf "${NEST_IN__TS_U}%s${NEST_IN__TS_N}\n" "$target"

		target-script "$target"
		local script=("${TARGET_SCRIPT_RETURN__SCRIPT[@]}")
		printf '  %s\n' "${script[@]}"
	done
}

EXEC_SCRIPT_RETURN__FAILED_LINE=''
exec-script()
{
	local nest_in__script=("$@")

	EXEC_SCRIPT_RETURN__FAILED_LINE=''

	local nest_in__line
	for nest_in__line in "${nest_in__script[@]}"
	do
		eval "$nest_in__line"
		if [ $? != 0 ]
		then
			EXEC_SCRIPT_RETURN__FAILED_LINE="$nest_in__line"
			return 1
		fi
	done
}

start-nesting-impl()
{
	local targets=("$@")

	local target
	for target in "${targets[@]}"
	do
		if is-target-marked "$target"
		then
			continue
		fi

		printf-nest-in-message 'resolving dependencies for %s...' "$target"
		target-dependencies "$target"
		local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
		if [ ${#dependencies[@]} != 0 ]
		then
			start-nesting-impl "${dependencies[@]}"
			if [ $? != 0 ]
			then
				return 1
			fi
		fi

		target-script "$target"
		local script=("${TARGET_SCRIPT_RETURN__SCRIPT[@]}")
		if [[ ${#script[@]} > 0 ]]
		then
			printf-nest-in-message 'working on %s...' "$target"
			exec-script "${script[@]}"
			if [ $? != 0 ]
			then
				printf-error 'failed to install "%s"\nthe following command failed:\n> %s' "$target" "$EXEC_SCRIPT_RETURN__FAILED_LINE"
				return 1
			fi
		fi

		mark-target "$target"
	done
}

start-nesting()
{
	printf-message 'Nesting...'
	start-nesting-impl "$@"
	if [ $? != 0 ]
	then
		return 1
	fi

	printf-message '\nNesting finished.\nWelcome home!'
}

#
# Main

gather-system-info

{ # Deal with arguments
	parse-arguments "$@" && validate-and-apply-options
	if [ $? != 0 ]
	then
		exit 1
	fi
}

{ # Do the work
	printf-message 'Gathering twigs...'
	gather-twigs $NEST_IN__TWIGS_DESCRIPTOR
	if [ $? != 0 ]
	then
		exit 1
	fi

	gathered_targets=("${GATHER_TWIGS_RETURN__TARGETS[@]}")
	gathered_explicit_targets=("${GATHER_TWIGS_RETURN__DESIGNATED_TARGETS[@]}")

	check-all-targets-exist "${gathered_targets[@]}" "${gathered_explicit_targets[@]}" &&
	check-theres-no-circular-dependencies "${gathered_targets[@]}" "${gathered_explicit_targets[@]}" &&
	check-input-targets-exist "${gathered_targets[@]}" "${gathered_explicit_targets[@]}"
	if [ $? != 0 ]
	then
		exit 1
	fi

	if [[ ${#NEST_IN__INPUT_TARGETS[@]} == 0 ]]
	then
		targets=("${gathered_targets[@]}")
	else
		targets=("${NEST_IN__INPUT_TARGETS[@]}")
	fi

	do-the-work "${targets[@]}"
}

