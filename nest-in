#!/bin/bash

#
# Essentials

NEST_IN__SCRIPT_NAME=nest-in

NEST_IN__TS_N='\e[0m'
NEST_IN__TS_B='\e[1m'
NEST_IN__TS_U='\e[4m'
TS_ERROR='\e[0;31m'

NEST_IN__TS_ERR=''
NEST_IN__TS_ERR_END=''
if [ -t 1 ] && [ $(tput colors) \> 0 ]
then
	NEST_IN__TS_ERR="$TS_ERROR"
	NEST_IN__TS_ERR_END="$NEST_IN__TS_N"
fi

printf-stderr()
{
	printf "$@" >&2
}

printf-error()
{
	printf-stderr "$NEST_IN__TS_ERR$NEST_IN__SCRIPT_NAME error:$NEST_IN__TS_ERR_END "
	printf-stderr "$@"
	printf-stderr '\n'
}

printf-message()
{
	printf "$@"
	printf '\n'
}

printf-nest-in-message()
{
	printf-stderr "${NEST_IN__TS_U}$NEST_IN__SCRIPT_NAME${NEST_IN__TS_N}: "
	printf-stderr "$@"
	printf-stderr '\n'
}

print-help()
{
	printf \
"${NEST_IN__TS_B}USAGE${NEST_IN__TS_N}
  ${NEST_IN__TS_B}nest-in${NEST_IN__TS_N} [${NEST_IN__TS_U}-dsr${NEST_IN__TS_N}] [${NEST_IN__TS_U}targets...${NEST_IN__TS_N}] [${NEST_IN__TS_U}-k${NEST_IN__TS_N}] -- [${NEST_IN__TS_U}file${NEST_IN__TS_N}]

${NEST_IN__TS_B}OPTIONS${NEST_IN__TS_N}
  [${NEST_IN__TS_U}targets${NEST_IN__TS_N}...]  Specify targets to work with.
  ${NEST_IN__TS_B}-d${NEST_IN__TS_N}            Show dependencies for targets.
  ${NEST_IN__TS_B}-s${NEST_IN__TS_N}            Show scenarios for targets.
  ${NEST_IN__TS_B}--${NEST_IN__TS_N} ${NEST_IN__TS_U}file${NEST_IN__TS_N}       Read nesting info from ${NEST_IN__TS_U}file${NEST_IN__TS_N}.
  ${NEST_IN__TS_B}--${NEST_IN__TS_N}            Read nesting info from from ${NEST_IN__TS_U}stdin${NEST_IN__TS_N}.
  ${NEST_IN__TS_B}-h${NEST_IN__TS_N}            Show this message.

${NEST_IN__TS_B}More information at${NEST_IN__TS_N} ${NEST_IN__TS_U}https://github.com/shrpnsld/nest-in${NEST_IN__TS_N}
"
}

#
# Constants

NEST_IN__CONFIG_DIR_PATH="$HOME/.config/$NEST_IN__SCRIPT_NAME"
NEST_IN__CONFIG_FILE_NAME='twigs.txt'
NEST_IN__DEFAULT_TWIGS_PATH="$NEST_IN__CONFIG_DIR_PATH/$NEST_IN__CONFIG_FILE_NAME"

NEST_IN__SYNTAX_NOTE=\
"${NEST_IN__TS_U}Note${NEST_IN__TS_N}:
  - only one target is allowed per declaration
  - commands in scenario should be preceeded by any-sort of whitespace
  - scenario should end with blank line"


#
# Options

NEST_IN__TWIGS_PATH=''
NEST_IN__TWIGS_DESCRIPTOR=-1
NEST_IN__INPUT_TARGETS=()
NEST_IN__DELIMITER_PASSED=false

NEST_IN__DO_THE_WORK=:
do-the-work()
{
	"$NEST_IN__DO_THE_WORK" "$@"
}

#
# Functions

PARAMETER_TYPE_OPTION=1
PARAMETER_TYPE_TARGET=2
PARAMETER_TYPE_DELIMITER=3
PARAMETER_TYPE_BAD=255
PARAMETER_TYPE_RETURN__PARAMETER=''
parameter-type()
{
	local string=$1

	if [ "${string:0:3}" == '--' ] && [ "${#string}" == 2 ]
	then
		return $PARAMETER_TYPE_DELIMITER
	fi

	if [ "${string:0:1}" == '-' ]
	then
		PARAMETER_TYPE_RETURN__PARAMETER="${string#-}"
		return $PARAMETER_TYPE_OPTION
	fi

	if [[ $string =~ ^[a-zA-Z]+[a-zA-Z0-9_\-]*$ ]]
	then
		PARAMETER_TYPE_RETURN__PARAMETER="$string"
		return $PARAMETER_TYPE_TARGET
	fi

	return $PARAMETER_TYPE_BAD
}

PARSE_OPTION_UNKNOWN_OPTION=255
parse-option()
{
	local option=$1
	local value=$2

	case "$option" in
		d)
			NEST_IN__DO_THE_WORK=show-dependencies
			;;

		s)
			NEST_IN__DO_THE_WORK=show-scenarios
			;;

		h)
			print-help
			exit
			;;

		*)
			return $PARSE_OPTION_UNKNOWN_OPTION
			;;
	esac
}

parse-arguments()
{
	local parameters=("$@")

	local parameter_index
	for (( parameter_index = 0; parameter_index < ${#parameters[@]}; ++parameter_index ))
	do
		local parameter
		parameter-type "${parameters[$parameter_index]}"
		local parameter_type=$?
		parameter="$PARAMETER_TYPE_RETURN__PARAMETER"
		case $parameter_type in
			$PARAMETER_TYPE_OPTION)
				local value="${parameters[$parameter_index + 1]}"
				local option_index
				for (( option_index = 0; option_index < ${#parameter}; ++option_index ))
				do
					local option="${parameter:$option_index:1}"
					parse-option "$option" "$value"
					local retval=$?
					case $retval in
						$PARSE_OPTION_UNKNOWN_OPTION)
							printf-error 'unknown option "%s"' "$option"
							return 1
							;;

						*)
							(( parameter_index += retval ))
							: # so the result of arithmetic above does not considered as a result of case-clause execution
							;;
					esac
				done

				continue
				;;

			$PARAMETER_TYPE_TARGET)
				NEST_IN__INPUT_TARGETS+=("$parameter")
				;;

			$PARAMETER_TYPE_DELIMITER)
				(( ++parameter_index ))
				NEST_IN__DELIMITER_PASSED=true
				NEST_IN__TWIGS_PATH="${parameters[$parameter_index]}"
				break
				;;

			$PARAMETER_TYPE_BAD)
				printf-error 'bad parameter format "%s"' "$parameter"
				return 1
				;;
		esac
	done
}

validate-and-apply-options()
{
	if [ -n "$NEST_IN__TWIGS_PATH" ]
	then
		exec 3< "$NEST_IN__TWIGS_PATH"
		NEST_IN__TWIGS_DESCRIPTOR=3
	elif $NEST_IN__DELIMITER_PASSED
	then
		NEST_IN__TWIGS_DESCRIPTOR=0
	else
		if ! [ -r "$NEST_IN__DEFAULT_TWIGS_PATH" ]
		then
			printf-error 'failed to open config file "%s"' "$NEST_IN__DEFAULT_TWIGS_PATH"
			exit 1
		fi

		exec 3< "$NEST_IN__DEFAULT_TWIGS_PATH"
		NEST_IN__TWIGS_DESCRIPTOR=3
	fi

	if [ "$NEST_IN__DO_THE_WORK" == : ]
	then
		NEST_IN__DO_THE_WORK=start-nesting
	fi
}

#PLATFORM_OS_NAME=''
#detect-platform()
#{
#	if [ -f /etc/os-release ]
#	then
#		# freedesktop.org and systemd
#		. /etc/os-release
#		PLATFORM_OS_NAME=$NAME
#		VER=$VERSION_ID
#	elif type lsb_release >/dev/null 2>&1
#	then
#		# linuxbase.org
#		PLATFORM_OS_NAME=$(lsb_release -si)
#		VER=$(lsb_release -sr)
#	elif [ -f /etc/lsb-release ]
#	then
#		# For some versions of Debian/Ubuntu without lsb_release command
#		. /etc/lsb-release
#		PLATFORM_OS_NAME=$DISTRIB_ID
#		VER=$DISTRIB_RELEASE
#	elif [ -f /etc/debian_version ]
#	then
#		# Older Debian/Ubuntu/etc.
#		PLATFORM_OS_NAME=Debian
#		VER=$(cat /etc/debian_version)
#	else
#		# Fall back to uname, e.g. "Linux <version>", also works for BSD, etc.
#		PLATFORM_OS_NAME=$(uname -s)
#		VER=$(uname -r)
#	fi
#}

is-target-declaration()
{
	local line=$1

	[[ $line =~ ^[a-zA-Z]+[a-zA-Z0-9_\-]*[\ \t]*$ ]] ||
	[[ $line =~ ^[a-zA-Z]+[a-zA-Z0-9_\-]*[\ \t]*\/([\ \t]*[a-zA-Z]+[a-zA-Z0-9_\-]*)*[\ \t]*$ ]]
}

is-scenario-declaration()
{
	local line=$1

	[[ $line =~ ^[[:space:]]+[^[:space:]]+.*$ ]]
}

EXTRACT_TARGET_RETURN__TARGET=''
extract-target()
{
	local line=$1

	local old_IFS="$IFS"
	IFS=$' '

	line=(${line[@]})
	EXTRACT_TARGET_RETURN__TARGET="${line[0]}"

	IFS="$old_IFS"
}

EXTRACT_DEPENDENCIES_RETURN__DEPENDENCIES=()
extract-dependencies()
{
	local line=$1

	EXTRACT_DEPENDENCIES_RETURN__DEPENDENCIES=()

	if [[ $line != */* ]]
	then
		return
	fi

	local old_IFS="$IFS"
	IFS=$' '

	EXTRACT_DEPENDENCIES_RETURN__DEPENDENCIES=(${line#*/})

	IFS="$old_IFS"
}

variable-name-from-target()
{
	local string=$1

	tr '-' '_' <<< "$string"
}

READ_FILE_RETURN__LINE_NUMBER=0

PEEK_FILE_RETURN__LINE=''
peek-file()
{
	local descriptor=$1

	if [ -z "$PEEK_FILE_RETURN__LINE" ]
	then
		read -u $descriptor -r PEEK_FILE_RETURN__LINE
		if [ $? != 0 ]
		then
			return 1
		fi

		(( ++READ_FILE_RETURN__LINE_NUMBER ))
	fi
}

READ_FILE_RETURN__LINE=''
read-file()
{
	local descriptor=$1

	if [ -n "$PEEK_FILE_RETURN__LINE" ]
	then
		READ_FILE_RETURN__LINE="$PEEK_FILE_RETURN__LINE"
		PEEK_FILE_RETURN__LINE=''
	else
		read -u $descriptor -r READ_FILE_RETURN__LINE
		if [ $? != 0 ]
		then
			return 1
		fi

		(( ++READ_FILE_RETURN__LINE_NUMBER ))
	fi
}

next-non-empty-line()
{
	local descriptor=$1

	while true
	do
		peek-file $descriptor
		if [ $? != 0 ]
		then
			return 1
		fi

		if [ -n "$PEEK_FILE_RETURN__LINE" ]
		then
			break
		fi
	done
}

PARSE_TARGET_DECLARATION_RETURN__TARGET=''
parse-target-declaration()
{
	local line=$1

	extract-target "$line"
	local target="$EXTRACT_TARGET_RETURN__TARGET"
	extract-dependencies "$line"
	local dependencies=("${EXTRACT_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")

	local target_variable_name=$(variable-name-from-target "$target")
	eval "NEST_IN__DEPENDENCIES_${target_variable_name}=(${dependencies[@]})"

	PARSE_TARGET_DECLARATION_RETURN__TARGET="$target"
}

READ_TARGET_SCENARIO_CODE__BAD_SYNTAX=1
READ_TARGET_SCENARIO_CODE__EOF=2
READ_TARGET_SCENARIO_RETURN__SCENARIO=''
read-target-scenario()
{
	local descriptor=$1

	READ_TARGET_SCENARIO_RETURN__SCENARIO=''

	while true
	do
		read-file $descriptor
		if [ $? != 0 ]
		then
			return $READ_TARGET_SCENARIO_CODE__EOF
		fi

		local line="$READ_FILE_RETURN__LINE"
		if [ -z "$line" ]
		then
			return
		fi

		READ_TARGET_SCENARIO_RETURN__SCENARIO+="$line"$'\n'

		if ! is-scenario-declaration "$line"
		then
			return $READ_TARGET_SCENARIO_CODE__BAD_SYNTAX
		fi
	done
}

GATHER_TWIGS_RETURN__TARGETS=()
gather-twigs()
{
	local descriptor=$1

	GATHER_TWIGS_RETURN__TARGETS=()

	local old_IFS="$IFS"
	IFS=$'\n'

	while true
	do
		local target
		while true
		do
			next-non-empty-line $descriptor &&
			peek-file $descriptor &&
			is-target-declaration "$PEEK_FILE_RETURN__LINE" &&
			read-file $descriptor &&
			parse-target-declaration "$READ_FILE_RETURN__LINE"
			if [ $? != 0 ]
			then
				break
			fi

			target="$PARSE_TARGET_DECLARATION_RETURN__TARGET"
			GATHER_TWIGS_RETURN__TARGETS+=("$target")
			unmark-target "$target" # basically create information about mark
		done

		if [ -n "$PEEK_FILE_RETURN__LINE" ] && ! is-scenario-declaration "$PEEK_FILE_RETURN__LINE"
		then
			printf-error '%s:%d, unkown declaration "%s"\n'"$NEST_IN__SYNTAX_NOTE" "$NEST_IN__TWIGS_PATH" $READ_FILE_RETURN__LINE_NUMBER "$PEEK_FILE_RETURN__LINE"
			exit 1
		fi

		read-target-scenario $descriptor
		local retval=$?
		if [ $retval == $READ_TARGET_SCENARIO_CODE__BAD_SYNTAX ]
		then
			printf-error '%s:%d, malformed scenario for target "%s":\n%s\n'"$NEST_IN__SYNTAX_NOTE" "$NEST_IN__TWIGS_PATH" $READ_FILE_RETURN__LINE_NUMBER "$target" "$READ_TARGET_SCENARIO_RETURN__SCENARIO"
			exit 1
		elif [ $retval == $READ_TARGET_SCENARIO_CODE__EOF ]
		then
			break
		fi

		local variable_name=$(variable-name-from-target "$target")
		printf -v "NEST_IN__SCENARIO_${variable_name}" '%s' "$READ_TARGET_SCENARIO_RETURN__SCENARIO"
	done

	IFS="$old_IFS"
}

array-contains-item()
{
	local item=$1
	local array=("${@:2}")

	local current
	for current in ${array[@]}
	do
		if [ "$current" == "$item" ]
		then
			return 0
		fi
	done

	return 1
}

DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES=()
dependencies-for-target()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	eval "DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES=("\${NEST_IN__DEPENDENCIES_${variable_name}[@]}")"
}

dependencies-for-target-recursive()
{
	local target=$1

	dependencies-for-target "$target"
	local dependencies=("${DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES[@]}")
	if [[ ${#dependencies[@]} == 0 ]]
	then
		return
	fi

	printf '  %s\n' "${dependencies[@]}"
	for dependency in "${dependencies[@]}"
	do
		dependencies-for-target-recursive "$dependency"
	done
}

check-all-targets-exist()
{
	local targets=("$@")

	local any_errors=false
	local target
	for target in "${targets[@]}"
	do
		dependencies-for-target "$target"
		local dependencies=("${DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES[@]}")
		for dependency in "${dependencies[@]}"
		do
			if ! array-contains-item "$dependency" "${targets[@]}"
			then
				printf-error 'unknown dependency "%s" for target "%s"' "$dependency" "$target"
				any_errors=true
			fi
		done
	done

	! $any_errors
}

FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH=''
find-circular-dependencies-impl()
{
	local target_to_depend=$1
	local targets=("${@:2}")

	if array-contains-item "$target_to_depend" "${targets[@]}"
	then
		FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH="$target_to_depend"
		return 0
	fi

	local target
	for target in "${targets[@]}"
	do
		if is-target-marked "$target"
		then
			continue
		fi

		mark-target "$target"

		dependencies-for-target "$target"
		local dependencies=("${DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES[@]}")
		find-circular-dependencies-impl "$target_to_depend" "${dependencies[@]}"
		if [ $? == 0 ]
		then
			FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH="$target -> $FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH"
			return 0
		fi
	done

	return 1
}

find-circular-dependencies()
{
	local target=$1

	dependencies-for-target "$target"
	local dependencies=("${DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES[@]}")
	find-circular-dependencies-impl "$target" "${dependencies[@]}"
	local retval=$?
	FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH="$target -> $FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH"
	unmark-targets "${dependencies[@]}"
	return $retval
}

check-theres-no-circular-dependencies()
{
	local targets=("$@")

	local target
	for target in "${targets[@]}"
	do
		if find-circular-dependencies "$target"
		then
			printf-error 'circular dependency was found: %s' "$FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH"
			return 1
		fi
	done
}

check-input-targets-exist()
{
	local gathered_targets=("$@")

	for target in "${NEST_IN__INPUT_TARGETS[@]}"
	do
		if ! array-contains-item "$target" "${gathered_targets[@]}"
		then
			printf-error 'unkown target "%s" in arguments' "$target"
			return 1
		fi
	done
}

SCENARIO_FOR_TARGET_RETURN__SCENARIO=''
scenario-for-target()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	eval "SCENARIO_FOR_TARGET_RETURN__SCENARIO=(\"\$NEST_IN__SCENARIO_${variable_name}\")"
}

is-target-marked()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_installed="NEST_IN__MARKED_${variable_name}"
	${!target_installed}
}

unmark-target()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_installed="NEST_IN__MARKED_${variable_name}"
	printf -v "$target_installed" false
}

mark-target()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_installed="NEST_IN__MARKED_${variable_name}"
	printf -v "$target_installed" true
}

unmark-targets()
{
	local targets=("$@")

	for target in "${targets[@]}"
	do
		unmark-target "$target"
	done
}

show-dependencies()
{
	local targets=("$@")

	local target="${targets[0]}"
	printf "${NEST_IN__TS_U}%s${NEST_IN__TS_N}\n" "$target"
	dependencies-for-target-recursive "$target" | sort | uniq

	for target in "${targets[@]:1}"
	do
		printf '\n'
		printf "${NEST_IN__TS_U}%s${NEST_IN__TS_N}\n" "$target"
		dependencies-for-target-recursive "$target" | sort | uniq
	done
}

show-scenarios()
{
	local targets=("$@")

	local target="${targets[0]}"
	printf "${NEST_IN__TS_U}%s${NEST_IN__TS_N}\n" "$target"

	scenario-for-target "$target"
	local scenario="$SCENARIO_FOR_TARGET_RETURN__SCENARIO"
	printf '%s' "$scenario"

	for target in "${targets[@]:1}"
	do
		printf '\n'
		printf "${NEST_IN__TS_U}%s${NEST_IN__TS_N}\n" "$target"

		scenario-for-target "$target"
		local scenario="$SCENARIO_FOR_TARGET_RETURN__SCENARIO"
		printf '%s' "$scenario"
	done
}

exec-scenario()
{
	# hiding local variables,
	# and allowing exiting scenario with 'return'

	eval "$1"
}

start-nesting()
{
	local targets=("$@")

	local target
	for target in "${targets[@]}"
	do
		if is-target-marked "$target"
		then
			continue
		fi

		printf-nest-in-message 'resolving dependencies for %s...' "$target"
		dependencies-for-target "$target"
		local dependencies=("${DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES[@]}")
		if [ ${#dependencies[@]} != 0 ]
		then
			start-nesting "${dependencies[@]}"
		fi

		scenario-for-target "$target"
		local scenario="$SCENARIO_FOR_TARGET_RETURN__SCENARIO"

		printf-nest-in-message 'working on %s...' "$target"
		exec-scenario "$scenario"
		if [ $? != 0 ]
		then
			printf-error 'failed to install "%s"' "$target"
			exit
		fi

		mark-target "$target"
	done
}

#
# Main

{ # Deal with arguments
	parse-arguments "$@" && validate-and-apply-options
	if [ $? != 0 ]
	then
		exit 1
	fi
}

{ # Do the work
	gather-twigs $NEST_IN__TWIGS_DESCRIPTOR
	gathered_targets=("${GATHER_TWIGS_RETURN__TARGETS[@]}")

	check-all-targets-exist "${gathered_targets[@]}" &&
	check-theres-no-circular-dependencies "${gathered_targets[@]}" &&
	check-input-targets-exist "${gathered_targets[@]}"
	if [ $? != 0 ]
	then
		exit 1
	fi

	if [[ ${#NEST_IN__INPUT_TARGETS[@]} == 0 ]]
	then
		targets=("${gathered_targets[@]}")
	else
		targets=("${NEST_IN__INPUT_TARGETS[@]}")
	fi

	do-the-work "${targets[@]}"
}

