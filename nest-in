#!/bin/bash

#
# Essentials

readonly SCRIPT_NAME=nest-in

readonly TS_N='\e[0m'
readonly TS_B='\e[1m'
readonly TS_U='\e[4m'
readonly TS_ERROR='\e[0;31m'

TS_ERR=''
TS_ERR_END=''
if [ -t 1 ] && [ $(tput colors) \> 0 ]
then
	TS_ERR="$TS_ERROR"
	TS_ERR_END="$TS_N"
fi

readonly TS_ERR TS_ERR_END

printf-stderr()
{
	printf "$@" >&2
}

printf-error()
{
	printf-stderr "$TS_ERR$SCRIPT_NAME error:$TS_ERR_END "
	printf-stderr "$@"
	printf-stderr '\n'
}

printf-message()
{
	printf "$@"
	printf '\n'
}

print-help()
{
	printf \
"${TS_B}USAGE${TS_N}
  ${TS_B}nest-in${TS_N} [${TS_U}-dsr${TS_N}] [${TS_U}targets...${TS_N}] [${TS_U}-k${TS_N}] -- [${TS_U}file${TS_N}]

${TS_B}OPTIONS${TS_N}
  [${TS_U}targets${TS_N}...]   Specify targets to work with.
  ${TS_B}-d${TS_N}             Show dependencies for targets.
  ${TS_B}-n${TS_N}             Assemble work script, but don't run it.
  ${TS_B}--system-info${TS_N}  Print detected system information.
  ${TS_B}--${TS_N} ${TS_U}file${TS_N}        Read nesting info from ${TS_U}file${TS_N}.
  ${TS_B}--${TS_N}             Read nesting info from from ${TS_U}stdin${TS_N}.
  ${TS_B}-h${TS_N}             Show this message.

${TS_B}More information at${TS_N} ${TS_U}https://github.com/shrpnsld/nest-in${TS_N}
"
}

min-number()
{
	local first=$1
	local second=$2

	if [[ $first < $second ]]
	then
		return $first
	else
		return $second
	fi
}

max-number()
{
	local first=$1
	local second=$2

	if [[ $first > $second ]]
	then
		return $first
	else
		return $second
	fi
}

versions-equal()
{
	local first=$1
	local second=$2

	local old_IFS="$IFS"
	IFS='.'

	first=($first)
	second=($second)

	min-number ${#first[@]} ${#second[@]}
	local component_count=$?
	local result=0
	local index
	for (( index = 0; index < component_count; ++index ))
	do
		if [[ ${first[index]} != ${second[index]} ]]
		then
			result=1
			break
		fi
	done

	IFS="$old_IFS"

	return $result
}

#
# Constants

readonly DEFAULT_TWIGS_PATH="$HOME/.config/$SCRIPT_NAME/twigs.txt"
readonly WORK_SCRIPT_PATH='/tmp/nest-in-work'
readonly TARGET_FIRST_STEP_NAME='_FIRST_STEP'
readonly TARGET_LAST_STEP_NAME='_LAST_STEP'

#
# Globals

TWIGS_PATH="$DEFAULT_TWIGS_PATH"
TWIGS_DESCRIPTOR=-1
ALL_TARGETS=()
REGULAR_TARGETS=()
FIRST_STEP=''
LAST_STEP=''
INPUT_TARGETS=()

DO_THE_WORK=:
do-the-work()
{
	"$DO_THE_WORK" "$@"
}

DEAL_WITH_SCRIPT=run-script
deal-with-script()
{
	"$DEAL_WITH_SCRIPT" "$@"
}

#
# Requirements

extract-value()
{
	local value=$1
	local line=$2

	line="${line#${value}=}"
	line="${line#\"*}"
	line="${line%*\"}"

	printf '%s' "$line"
}

gather-linux-info()
{
	if [ ! -r /etc/os-release ]
	then
		SYSTEM_INFO__LINUX_FAMILY=unknown
		SYSTEM_INFO__LINUX_DISTRIBUTION=unknown
		SYSTEM_INFO__OS_VERSION=unknown
		return
	fi

	local line=$(grep '^ID=' /etc/os-release)
	SYSTEM_INFO__LINUX_DISTRIBUTION=$(extract-value 'ID' "$line")

	line=$(grep '^ID_LIKE=' /etc/os-release)
	SYSTEM_INFO__LINUX_FAMILY=$(extract-value 'ID_LIKE' "$line")

	line=$(grep '^VERSION_ID=' /etc/os-release)
	SYSTEM_INFO__OS_VERSION=$(extract-value 'VERSION_ID' "$line")

	if [[ $SYSTEM_INFO__LINUX_FAMILY == *debian* ]] # Elementary OS stores ID_LIKE="ubuntu debian"
	then
		SYSTEM_INFO__LINUX_FAMILY='debian'
	elif [[ $SYSTEM_INFO__LINUX_FAMILY == *suse* ]] # OpenSuSE stores ID_LIKE="suse opensuse"
	then
		SYSTEM_INFO__LINUX_FAMILY='suse'
	elif [ -z "$SYSTEM_INFO__LINUX_FAMILY" ]
	then
		if [ -f /etc/arch-release ]
		then
			SYSTEM_INFO__LINUX_FAMILY='arch'
		elif [ -f /etc/debian_version ]
		then
			SYSTEM_INFO__LINUX_FAMILY='debian'
		elif [ -f /etc/redhat-release ]
		then
			SYSTEM_INFO__LINUX_FAMILY='redhat'
		fi
	fi

	if [[ $SYSTEM_INFO__LINUX_DISTRIBUTION == opensuse* ]] # OpenSUSE stores ID="opensuse-leap"
	then
		SYSTEM_INFO__LINUX_DISTRIBUTION=opensuse
	elif [ -z "$SYSTEM_INFO__LINUX_DISTRIBUTION" ]
	then
		if [[ $SYSTEM_INFO__LINUX_FAMILY == arch ]]
		then
			SYSTEM_INFO__LINUX_DISTRIBUTION=$(lsb_release -id --short | awk '{ print $1 }' | tr '[:upper:]' '[:lower:]')
		elif [[ $SYSTEM_INFO__LINUX_FAMILY == debian ]]
		then
			SYSTEM_INFO__LINUX_DISTRIBUTION=$(lsb_release -id --short | head -1 | tr '[:upper:]' '[:lower:]')
		elif [[ $SYSTEM_INFO__LINUX_FAMILY == redhat ]]
		then
			SYSTEM_INFO__LINUX_DISTRIBUTION=$(awk '{ print $1 }' /etc/redhat-release | tr '[:upper:]' '[:lower:]')
		fi
	fi

	# Tails stores VERSION="x.y.z"
	if [ -z "$SYSTEM_INFO__OS_VERSION" ]
	then
		line=$(grep '^VERSION=' /etc/os-release)
		local version=$(extract-value 'VERSION' "$line")
		if [[ $version =~ ^[0-9]+[0-9\.]*[0-9]+$ ]]
		then
			SYSTEM_INFO__OS_VERSION="$version"
		fi
	fi

	if [ -z "$SYSTEM_INFO__OS_VERSION" ]
	then
		if [[ $SYSTEM_INFO__LINUX_FAMILY == arch ]]
		then
			SYSTEM_INFO__OS_VERSION=$(lsb_release --release --short)
		elif [[ $SYSTEM_INFO__LINUX_FAMILY == debian ]]
		then
			SYSTEM_INFO__OS_VERSION=$(grep '^DISTRIB_RELEASE' /etc/lsb-release | awk -F= '{ print $2 }')
		elif [[ $SYSTEM_INFO__LINUX_FAMILY == redhat ]]
		then
			SYSTEM_INFO__OS_VERSION=$(awk '{ print $3 }' /etc/redhat-release)
		fi
	fi
}

gather-system-info()
{
	case "$OSTYPE" in
		darwin*)
			SYSTEM_INFO__OS=macos
			SYSTEM_INFO__LINUX_FAMILY=''
			SYSTEM_INFO__LINUX_DISTRIBUTION=''
			SYSTEM_INFO__OS_VERSION=$(sw_vers --productVersion)
			;;

		linux*)
			SYSTEM_INFO__OS='linux'
			gather-linux-info
			;;

		cygwin)
			SYSTEM_INFO__OS=cygwin
			SYSTEM_INFO__LINUX_FAMILY=''
			SYSTEM_INFO__LINUX_DISTRIBUTION=''
			SYSTEM_INFO__OS_VERSION=''
			;;

		msys)
			SYSTEM_INFO__OS=msys
			SYSTEM_INFO__LINUX_FAMILY=''
			SYSTEM_INFO__LINUX_DISTRIBUTION=''
			SYSTEM_INFO__OS_VERSION=''
			;;
	esac

	readonly \
		SYSTEM_INFO__OS \
		SYSTEM_INFO__LINUX_FAMILY \
		SYSTEM_INFO__LINUX_DISTRIBUTION \
		SYSTEM_INFO__OS_VERSION
}

print-system-info()
{
	printf 'os: "%s"\n' "$SYSTEM_INFO__OS"

	if [ -n "$SYSTEM_INFO__LINUX_FAMILY" ]
	then
		printf 'family: "%s"\n' "$SYSTEM_INFO__LINUX_FAMILY"
	fi

	if [ -n "$SYSTEM_INFO__LINUX_FAMILY" ]
	then
		printf 'distribution: "%s"\n' "$SYSTEM_INFO__LINUX_DISTRIBUTION"
	fi

	printf 'version: "%s"\n' "$SYSTEM_INFO__OS_VERSION"
}

os()
{
	local name=$1
	local version=$2

	[[ $SYSTEM_INFO__OS == $name ]] ||
	[[ $SYSTEM_INFO__LINUX_DISTRIBUTION == $name ]] &&

	if [ -n "$version" ]
	then
		versions-equal $SYSTEM_INFO__OS_VERSION $version
	fi
}

avail()
{
	local program=$1

	local type_of_object=$(type -t "$program")
	[[ $type_of_object == file ]] || [[ $type_of_object == function ]]
}

macos()
{
	local version=$1

	[[ $SYSTEM_INFO__OS == 'macos' ]] &&
	if [ -n "$version" ]
	then
		versions-equal $SYSTEM_INFO__OS_VERSION $version
	fi
}

linux()
{
	local family=$1
	local distribution=$2
	local version=$3

	[[ $SYSTEM_INFO__OS == 'linux' ]] &&
	if [ -n "$family" ]
	then
		[[ $SYSTEM_INFO__LINUX_FAMILY == $family ]]
	fi &&
	if [ -n "$distribution" ]
	then
		[[ $SYSTEM_INFO__LINUX_DISTRIBUTION == $distribution ]]
	fi &&
	if [ -n "$version" ]
	then
		versions-equal $SYSTEM_INFO__OS_VERSION $version
	fi
}

debian() { linux 'debian' "$@"; }
ubuntu() { debian 'ubuntu' "$@"; }
elementary() { debian 'elementary' "$@"; }
kali() { debian 'kali' "$@"; } # not tested yet
tails() { debian 'tails' "$@"; } # not tested yet

redhat() { linux 'redhat' "$@"; }
fedora() { redhat 'fedora' "$@"; }

arch() { linux 'arch' "$@"; }
manjaro() { arch 'manjaro' "$@"; }

suse() { linux 'suse' "$@"; }
opensuse() { suse 'opensuse' "$@"; }

cygwin() { [[ $SYSTEM_INFO__OS == 'cygwin' ]]; }

#
# Functions

readonly PARAMETER_TYPE_OPTION=1
readonly PARAMETER_TYPE_LONG_OPTION=2
readonly PARAMETER_TYPE_TARGET=3
readonly PARAMETER_TYPE_DELIMITER=4
readonly PARAMETER_TYPE_BAD=255
PARAMETER_TYPE_RETURN__PARAMETER=''
parameter-type()
{
	local string=$1

	if [[ ${string:0:2} == '--' && ${#string} == 2 ]]
	then
		return $PARAMETER_TYPE_DELIMITER
	fi

	if [[ ${string:0:2} == '--' ]]
	then
		PARAMETER_TYPE_RETURN__PARAMETER="${string#--}"
		return $PARAMETER_TYPE_LONG_OPTION
	fi

	if [[ ${string:0:1} == '-' ]]
	then
		PARAMETER_TYPE_RETURN__PARAMETER="${string#-}"
		return $PARAMETER_TYPE_OPTION
	fi

	if [[ $string =~ ^[a-zA-Z]+[a-zA-Z0-9_\-]*$ ]]
	then
		PARAMETER_TYPE_RETURN__PARAMETER="$string"
		return $PARAMETER_TYPE_TARGET
	fi

	return $PARAMETER_TYPE_BAD
}

PARSE_OPTION_UNKNOWN_OPTION=255
parse-option()
{
	local option=$1
	local value=$2

	case "$option" in
		d)
			DO_THE_WORK=show-targets
			;;

		n)
			DEAL_WITH_SCRIPT=cat-script
			;;

		system-info)
			print-system-info
			exit
			;;

		h)
			print-help
			exit
			;;

		*)
			return $PARSE_OPTION_UNKNOWN_OPTION
			;;
	esac
}

parse-arguments()
{
	local parameters=("$@")

	local parameter_index
	for (( parameter_index = 0; parameter_index < ${#parameters[@]}; ++parameter_index ))
	do
		local parameter
		parameter-type "${parameters[$parameter_index]}"
		local parameter_type=$?
		parameter="$PARAMETER_TYPE_RETURN__PARAMETER"
		case $parameter_type in
			$PARAMETER_TYPE_OPTION)
				local value="${parameters[$parameter_index + 1]}"
				local option_index
				for (( option_index = 0; option_index < ${#parameter}; ++option_index ))
				do
					local option="${parameter:$option_index:1}"
					parse-option "$option" "$value"
					local retval=$?
					case $retval in
						$PARSE_OPTION_UNKNOWN_OPTION)
							printf-error 'unknown option "%s"' "$option"
							return 1
							;;

						*)
							(( parameter_index += retval ))
							: # so the result of arithmetic above does not considered as a result of case-clause execution
							;;
					esac
				done

				continue
				;;

			$PARAMETER_TYPE_LONG_OPTION)
				parse-option "$parameter" "$value"
				continue
				;;

			$PARAMETER_TYPE_TARGET)
				INPUT_TARGETS+=("$parameter")
				;;

			$PARAMETER_TYPE_DELIMITER)
				(( ++parameter_index ))
				TWIGS_PATH="${parameters[$parameter_index]}"
				break
				;;

			$PARAMETER_TYPE_BAD)
				printf-error 'bad parameter format "%s"' "$parameter"
				return 1
				;;
		esac
	done
}

validate-and-apply-options()
{
	if [ -z "$TWIGS_PATH" ]
	then
		TWIGS_DESCRIPTOR=0
	else
		TWIGS_DESCRIPTOR=3
		open-file $TWIGS_DESCRIPTOR "$TWIGS_PATH" >/dev/null 2>&1
		if [ $? != 0 ]
		then
			printf-error 'failed to open config file "%s"' "$TWIGS_PATH"
			return 1
		fi
	fi

	if [[ $DO_THE_WORK == ':' ]]
	then
		DO_THE_WORK=start-nesting
	fi
}

open-file()
{
	local descriptor=$1
	local path=$2

	eval "exec $descriptor< \"$path\""
	if [ $? != 0 ]
	then
		return 1
	fi

	trap "exec $descriptor>&-" EXIT
}

FILE_READ_LINE_RETURN__LINE_NUMBER=0

FILE_PEEK_LINE_RETURN__LINE=''
FILE_PEEK_LINE_RETURN__PEEKED=false
file-peek-line()
{
	local descriptor=$1

	if $FILE_PEEK_LINE_RETURN__PEEKED
	then
		return
	fi

	read -u $descriptor -r FILE_PEEK_LINE_RETURN__LINE
	if [ $? != 0 ]
	then
		FILE_PEEK_LINE_RETURN__PEEKED=false
		return 1
	fi

	FILE_PEEK_LINE_RETURN__PEEKED=true
	(( ++FILE_READ_LINE_RETURN__LINE_NUMBER ))
}

FILE_READ_LINE_RETURN__LINE=''
file-read-line()
{
	local descriptor=$1

	if $FILE_PEEK_LINE_RETURN__PEEKED
	then
		FILE_READ_LINE_RETURN__LINE="$FILE_PEEK_LINE_RETURN__LINE"
		FILE_PEEK_LINE_RETURN__LINE=''
		FILE_PEEK_LINE_RETURN__PEEKED=false
	else
		read -u $descriptor -r FILE_READ_LINE_RETURN__LINE
		if [ $? != 0 ]
		then
			return 1
		fi

		FILE_PEEK_LINE_RETURN__LINE=''
		FILE_PEEK_LINE_RETURN__PEEKED=false
		(( ++FILE_READ_LINE_RETURN__LINE_NUMBER ))
	fi
}

next-non-empty-line()
{
	local descriptor=$1

	while true
	do
		if ! file-peek-line $descriptor
		then
			return
		fi

		if [ -n "$FILE_PEEK_LINE_RETURN__LINE" ]
		then
			break
		fi

		file-read-line $descriptor
	done
}

is-target-declaration()
{
	local line=$1

	# Example
	# target-name
	[[ $line =~ ^[[:alpha:]]+[[:alnum:]_\-]*[[:blank:]]*!?[[:blank:]]*$ ]] ||
	#            target-name...............             !

	# Example
	# target-name! / [requirement:specifier] [requirement] another-target and-another
	#                                                                               (                           |                                       |                   )(                                       |                                                   |                               )
	[[ $line =~ ^[[:alpha:]]+[[:alnum:]_\-]*[[:blank:]]*!?[[:blank:]]*\/[[:blank:]]*([[:alpha:]]+[[:alnum:]_\-]*|\[[[:alpha:]_\-]+\:[[:alnum:]:_\.\-]+\]|\[[[:alpha:]_\-]+\])([[:blank:]]+[[:alpha:]]+[[:alnum:]_\-]*|[[:blank:]]+\[[[:alpha:]_\-]+\:[[:alnum:]:_\.\-]+\]|[[:blank:]]+\[[[:alpha:]_\-]+\])*[[:blank:]]*$ ]] ||
	#            target-name................            !              /             dependency-name............  [requirement.... :specifier........ ]  [requirement..... ]              dependency-name............              [requirement.... :specifier......... ]              [requirement.... ]

	[[ $line =~ ^(\+|\-)[[:blank:]]*$ ]] ||

	# Example + / [requirement:specifier] [requirement]
	#            (  |  )                          (                                       |                   )(                                                   |                               )
	[[ $line =~ ^(\+|\-)[[:blank:]]*\/[[:blank:]]*(\[[[:alpha:]_\-]+\:[[:alnum:]:_\.\-]+\]|\[[[:alpha:]_\-]+\])([[:blank:]]+\[[[:alpha:]_\-]+\:[[:alnum:]:_\.\-]+\]|[[:blank:]]+\[[[:alpha:]_\-]+\])*$ ]]
	#              +  -              /              [requirement.... :specifier......... ]  [requirement.... ]               [requirement.... :specifier......... ]              [requirement.... ]
}

is-script-declaration()
{
	local line=$1

	[ -z "$line" ] || [[ $line =~ ^[[:blank:]]+.*$ ]]
}

EXTRACT_TARGET_RETURN__TARGET=''
extract-target()
{
	local line=$1

	line="${line%%/*}"
	line="${line%%!*}"
	EXTRACT_TARGET_RETURN__TARGET="${line%% *}"
}

readonly TARGET_TYPE_CODE__REGULAR=1
readonly TARGET_TYPE_CODE__FIRST_STEP=2
readonly TARGET_TYPE_CODE__LAST_STEP=3
readonly TARGET_TYPE_CODE__DEDICATED=4
target-type()
{
	if [[ $line =~ ^\+[[:blank:]]* ]]
	then
		return $TARGET_TYPE_CODE__FIRST_STEP
	elif [[ $line =~ ^\-[[:blank:]]* ]]
	then
		return $TARGET_TYPE_CODE__LAST_STEP
	elif [[ $line == *!* ]]
	then
		return $TARGET_TYPE_CODE__DEDICATED
	else
		return $TARGET_TYPE_CODE__REGULAR
	fi

}

EXTRACT_REQS_AND_DEPS_RETURN__REQUIREMENTS=()
EXTRACT_REQS_AND_DEPS_RETURN__DEPENDENCIES=()
extract-reqs-and-deps()
{
	local line=$1

	EXTRACT_REQS_AND_DEPS_RETURN__REQUIREMENTS=()
	EXTRACT_REQS_AND_DEPS_RETURN__DEPENDENCIES=()

	if [[ $line != */* ]]
	then
		return
	fi

	line=${line#*/}

	local old_IFS="$IFS"
	IFS=$' '

	local tokens=(${line#*/})
	for token in "${tokens[@]}"
	do
		if [[ ${token:0:1} == '[' ]]
		then
			token=${token#[}
			token=${token%]}
			EXTRACT_REQS_AND_DEPS_RETURN__REQUIREMENTS+=("$token")
		else
			EXTRACT_REQS_AND_DEPS_RETURN__DEPENDENCIES+=("$token")
		fi
	done

	IFS="$old_IFS"
}

array-contains-item()
{
	local item=$1
	local array=("${@:2}")

	local current
	for current in ${array[@]}
	do
		if [[ $current == $item ]]
		then
			return 0
		fi
	done

	return 1
}

array-sort()
{
	local old_IFS="$IFS"
	IFS=$'\n'
	printf '%s\n' "$@" | sort
	IFS="$old_IFS"
}

normalize-target-name()
{
	local target=$1

	case "$target" in
		$TARGET_FIRST_STEP_NAME)
			printf '%s' '+'
			;;

		$TARGET_LAST_STEP_NAME)
			printf '%s' '-'
			;;

		*)
			printf '%s' "$target"
			;;
	esac
}

variable-name-from-target()
{
	local string=$1

	tr '-' '_' <<< "$string"
}

is-target-marked()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_marked="DB__MARKED_${variable_name}"
	[[ ${!target_marked} != '' ]] && ${!target_marked}
}

target-unmark()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_marked="DB__MARKED_${variable_name}"
	printf -v "$target_marked" false
}

target-mark()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_marked="DB__MARKED_${variable_name}"
	printf -v "$target_marked" true
}

targets-unmark()
{
	local targets=("$@")

	local target
	for target in "${targets[@]}"
	do
		target-unmark "$target"
	done
}

TARGET_DECLARATION_RETURN__DECLARATION=''
TARGET_DECLARATION_RETURN__LINE_NUMBER=''
target-declaration()
{
	local target=$1
	local variant=$2

	if [ -z "$variant" ]
	then
		variant=0
	fi

	local variable_name=$(variable-name-from-target "$target")
	eval "TARGET_DECLARATION_RETURN__DECLARATION=(\"\${DB__DECLARATIONS_${variable_name}[$variant]}\")"
	eval "TARGET_DECLARATION_RETURN__LINE_NUMBER=(\"\${DB__DECLARATION_LINE_NUMBERS_${variable_name}[$variant]}\")"
}

target-add-declaration()
{
	local target=$1
	local line_number=$3
	local declaration=$2

	local variable_name=$(variable-name-from-target "$target")
	eval "DB__DECLARATIONS_${variable_name}+=(\"$declaration\")"
	eval "DB__DECLARATION_LINE_NUMBERS_${variable_name}+=($line_number)"
}

target-use-declaration-variant()
{
	local target=$1
	local variant=$2

	target-declaration "$target" $variant
	local declaration="$TARGET_DECLARATION_RETURN__DECLARATION"
	local line_number=$TARGET_DECLARATION_RETURN__LINE_NUMBER

	local variable_name=$(variable-name-from-target "$target")
	eval "DB__DECLARATIONS_${variable_name}[0]=\"$declaration\""
	eval "DB__DECLARATION_LINE_NUMBERS_${variable_name}[0]=$line_number"
}

TARGET_VARIANT_COUNT_RETURN__COUNT=
target-variant-count()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	eval "TARGET_VARIANT_COUNT_RETURN__COUNT=\${#DB__DECLARATIONS_${variable_name}[@]}"

}

TARGET_REQUIREMENTS_RETURN__REQUIREMENTS=()
target-requirements()
{
	local target=$1
	local variant=$2

	if [ -z "$variant" ]
	then
		variant=0
	fi

	local variable_name=$(variable-name-from-target "$target")
	local requirements
	eval "requirements=(\"\${DB__REQUIREMENTS_${variable_name}[$variant]}\")"

	local old_IFS="$IFS"
	IFS=$' '
	TARGET_REQUIREMENTS_RETURN__REQUIREMENTS=(${requirements[@]})
	IFS="$old_IFS"
}

target-add-requirements()
{
	local target=$1
	local requirements=("${@:2}")

	local old_IFS="$IFS"
	IFS=$' '
	requirements="${requirements[@]}"
	IFS="$old_IFS"

	local target_variable_name=$(variable-name-from-target "$target")
	eval "DB__REQUIREMENTS_${target_variable_name}+=(\"$requirements\")"
}

target-requirements-resolved()
{
	local target=$1

	local target_variable_name=$(variable-name-from-target "$target")
	eval "[[ \$DB__REQUIREMENTS_RESOLVED_${target_variable_name} ]]"
}

target-mark-requirements-resolved()
{
	local target=$1

	local target_variable_name=$(variable-name-from-target "$target")
	eval "DB__REQUIREMENTS_RESOLVED_${target_variable_name}=true"
}

TARGET_DEPENDENCIES_RETURN__DEPENDENCIES=()
target-dependencies()
{
	local target=$1
	local variant=$2

	if [ -z "$variant" ]
	then
		variant=0
	fi

	local variable_name=$(variable-name-from-target "$target")
	local dependencies
	eval "dependencies=(\"\${DB__DEPENDENCIES_${variable_name}[$variant]}\")"

	local old_IFS="$IFS"
	IFS=$' '
	TARGET_DEPENDENCIES_RETURN__DEPENDENCIES=(${dependencies[@]})
	IFS="$old_IFS"
}

target-dependencies-recursive-impl()
{
	local target=$1

	target-dependencies "$target"
	local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
	if [[ ${#dependencies[@]} == 0 ]]
	then
		return
	fi

	TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES+=("${dependencies[@]}")

	for dependency in "${dependencies[@]}"
	do
		target-dependencies-recursive-impl "$dependency"
	done
}

TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES=()
target-dependencies-recursive()
{
	local target=$1

	TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES=()

	target-dependencies-recursive-impl "$target"
	TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES=($(IFS=$'\n' sort <<< "${TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES[*]}" | uniq))
}

target-add-dependencies()
{
	local target=$1
	local dependencies=("${@:2}")

	local old_IFS="$IFS"
	IFS=$' '
	dependencies="${dependencies[@]}"
	IFS="$old_IFS"

	local target_variable_name=$(variable-name-from-target "$target")
	eval "DB__DEPENDENCIES_${target_variable_name}+=(\"$dependencies\")"
}

target-use-dependencies-variant()
{
	local target=$1
	local variant=$2

	local old_IFS="$IFS"
	IFS=$' '
	target-dependencies "$target" $variant
	local dependencies="${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}"
	IFS="$old_IFS"

	local target_variable_name=$(variable-name-from-target "$target")
	eval "DB__DEPENDENCIES_${target_variable_name}[0]=\"$dependencies\""
}

TARGET_SCRIPT_RETURN__SCRIPT=()
target-script()
{
	local target=$1
	local variant=$2

	if [ -z "$variant" ]
	then
		variant=0
	fi

	local variable_name=$(variable-name-from-target "$target")
	eval "TARGET_SCRIPT_RETURN__SCRIPT=(\"\${DB__SCRIPT_${variable_name}[$variant]}\")"
}

target-add-script()
{
	local target=$1
	local script=$2

	local variable_name=$(variable-name-from-target "$target")
	eval "DB__SCRIPT_${variable_name}+=(\"\$script\")"
}

target-use-script-variant()
{
	local target=$1
	local variant=$2

	local variable_name=$(variable-name-from-target "$target")
	local script
	eval "script=\"\${DB__SCRIPT_${variable_name}[$variant]}\""

	eval "DB__SCRIPT_${variable_name}[0]=\"\$script\""
}

target-use-variant()
{
	local target=$1
	local variant=$2

	target-use-declaration-variant "$target" $variant
	target-use-dependencies-variant "$target" $variant
	target-use-script-variant "$target" $variant
	target-mark-requirements-resolved "$target"
}

READ_TARGET_SCRIPT_RETURN__SCRIPT=''
read-target-script()
{
	local descriptor=$1

	READ_TARGET_SCRIPT_RETURN__SCRIPT=''

	while true
	do
		if ! file-peek-line $descriptor
		then
			return
		fi

		if ! is-script-declaration "$FILE_PEEK_LINE_RETURN__LINE"
		then
			break
		fi

		file-read-line $descriptor
		local line="$FILE_READ_LINE_RETURN__LINE"
		if [ -n "$line" ]
		then
			READ_TARGET_SCRIPT_RETURN__SCRIPT+="$line"$'\n'
		fi
	done
}

PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE=()
predicate-from-requirement()
{
	local requirement=$1

	PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE=()

	local old_IFS="$IFS"
	IFS=$':'

	PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE=(${requirement[@]})

	IFS="$old_IFS"
}

predicate-defined()
{
	local name=$1

	declare -f "$name" > /dev/null
}

readonly CHECK_REQUIREMENTS_CODE__UNKNOWN_NAME=255
CHECK_REQUIREMENTS_RETURN__VIOLATING_NAME=''
check-requirements()
{
	local requirements=("$@")

	for requirement in "${requirements[@]}"
	do
		predicate-from-requirement "$requirement"
		local predicate=("${PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE[@]}")
		if ! predicate-defined "${predicate[0]}"
		then
			CHECK_REQUIREMENTS_RETURN__VIOLATING_NAME="${predicate[0]}"
			return $CHECK_REQUIREMENTS_CODE__UNKNOWN_NAME
		fi

		if ! "${predicate[@]}"
		then
			return 1
		fi
	done
}

gather-twigs()
{
	local descriptor=$1

	local old_IFS="$IFS"
	IFS=

	while true
	do
		if ! next-non-empty-line $descriptor || ! file-peek-line $descriptor
		then
			break
		fi

		local line="$FILE_PEEK_LINE_RETURN__LINE"
		if ! is-target-declaration "$line"
		then
			printf-error 'bad declaration format\nline %d: %s' $FILE_READ_LINE_RETURN__LINE_NUMBER "$line"
			return 1
		fi

		file-read-line $descriptor
		line="$FILE_READ_LINE_RETURN__LINE"
		local line_number=$FILE_READ_LINE_RETURN__LINE_NUMBER
		target-type "$line"
		local target_type=$?

		local target
		if [[ $target_type == $TARGET_TYPE_CODE__FIRST_STEP ]]
		then
			FIRST_STEP="$TARGET_FIRST_STEP_NAME"
			target="$TARGET_FIRST_STEP_NAME"
		elif [[ $target_type == $TARGET_TYPE_CODE__LAST_STEP ]]
		then
			LAST_STEP="$TARGET_LAST_STEP_NAME"
			target="$TARGET_LAST_STEP_NAME"
		else
			extract-target "$line"
			target="$EXTRACT_TARGET_RETURN__TARGET"
		fi

		target-add-declaration "$target" "$line" $line_number

		extract-reqs-and-deps "$line"
		local dependencies=("${EXTRACT_REQS_AND_DEPS_RETURN__DEPENDENCIES[@]}")
		local requirements=("${EXTRACT_REQS_AND_DEPS_RETURN__REQUIREMENTS[@]}")
		target-add-requirements "$target" "${requirements[@]}"
		target-add-dependencies "$target" "${dependencies[@]}"

		if [[ $target_type == $TARGET_TYPE_CODE__REGULAR ]] && ! array-contains-item "$target" "${REGULAR_TARGETS[@]}"
		then
			REGULAR_TARGETS+=("$target")
		fi

		if ! array-contains-item "$target" "${ALL_TARGETS[@]}"
		then
			ALL_TARGETS+=("$target")
		fi

		if ! file-peek-line $descriptor
		then
			break
		fi

		line="$FILE_PEEK_LINE_RETURN__LINE"
		if ! is-script-declaration "$line"
		then
			continue
		fi

		if ! read-target-script $descriptor
		then
			break
		fi

		local script="$READ_TARGET_SCRIPT_RETURN__SCRIPT"
		target-add-script "$target" "$script"
	done
	IFS="$old_IFS"

	targets-unmark "${ALL_TARGETS[@]}"
}

make-error-message-unknown-requirement()
{
	local target=$1
	local index=$2
	local requirement=$3

	target-declaration "$target" $index
	local line_number=$TARGET_DECLARATION_RETURN__LINE_NUMBER
	local declaration="$TARGET_DECLARATION_RETURN__DECLARATION"
	printf 'unknown requirement "%s" for "%s"\n\n' "$requirement" $(normalize-target-name "$target")
	printf '%s\nline %d: %s\n' "$(realpath "$TWIGS_PATH")" $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
}

make-error-message-none-requirements-fulfilled()
{
	local target=$1

	printf 'none of "%s" variants have requirements fulfilled' $(normalize-target-name "$target")
}

make-error-message-duplicate-declarations()
{
	local target=$1
	local variants=("${@:2}")

	printf 'duplicate declarations for "%s"\n' "$target"

	printf '\n%s\n' "$(realpath "$TWIGS_PATH")"
	local variant
	for variant in "${variants[@]}"
	do
		target-declaration "$target" $variant
		printf 'line %d: %s\n' $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
	done
}

make-error-message-unknown-dependency()
{
	local target=$1
	local dependency=$2

	target-declaration "$target"
	printf 'unknown dependency "%s" for "%s"\n\n%s\nline %d: %s\n' "$dependency" "$target" "$(realpath "$TWIGS_PATH")" $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
}

make-error-message-circular-dependency()
{
	local dependency_path=("$@")

	printf 'circular dependency found\n'
	printf '%s -> ' "${dependency_path[@]}"
	printf '%s\n' "${dependency_path[0]}"

	printf '\n%s\n' "$(realpath "$TWIGS_PATH")"
	local target
	for target in "${dependency_path[@]}"
	do
		target-declaration "$target"
		printf 'line %d: %s\n' $TARGET_DECLARATION_RETURN__LINE_NUMBER "$TARGET_DECLARATION_RETURN__DECLARATION"
	done
}

TARGET_FIND_DUPLICATE_VARIANTS__INDEXES=()
target-find-duplicate-variants()
{
	local target=$1
	local variant=$2

	TARGET_FIND_DUPLICATE_VARIANTS__INDEXES=($variant)

	target-dependencies "$target" $variant
	local dependencies=$(array-sort "${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
	target-requirements "$target" $variant
	local requirements=$(array-sort "${TARGET_REQUIREMENTS_RETURN__REQUIREMENTS[@]}")

	target-variant-count "$target"
	local count=$TARGET_VARIANT_COUNT_RETURN__COUNT
	local duplicates=()
	local index
	for (( index = 0; index < count; ++index ))
	do
		if [[ $index == $variant ]]
		then
			continue
		fi

		target-dependencies "$target" $index
		local another_dependencies=$(array-sort "${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
		target-requirements "$target" $index
		local another_requirements=$(array-sort "${TARGET_REQUIREMENTS_RETURN__REQUIREMENTS[@]}")

		if [[ $dependencies == $another_dependencies && $requirements == $another_requirements ]]
		then
			TARGET_FIND_DUPLICATE_VARIANTS__INDEXES+=($index)
		fi
	done

	[[ ${#TARGET_FIND_DUPLICATE_VARIANTS__INDEXES[@]} == 1 ]]
}

TARGET_FIND_DUPLICATES_RETURN__INDEXES=()
target-find-duplicates()
{
	local target=$1

	TARGET_FIND_DUPLICATES_RETURN__INDEXES=()

	target-variant-count "$target"
	local count=$TARGET_VARIANT_COUNT_RETURN__COUNT
	local variant
	for (( variant = 0; variant < count; ++variant ))
	do
		if ! target-find-duplicate-variants "$target" $variant
		then
			TARGET_FIND_DUPLICATES_RETURN__INDEXES=("${TARGET_FIND_DUPLICATE_VARIANTS__INDEXES[@]}")
			return 1
		fi
	done
}

check-duplicates()
{
	local targets=("$@")

	for target in "${targets[@]}"
	do
		if ! target-find-duplicates "$target"
		then
			printf-error "$(make-error-message-duplicate-declarations "$target" "${TARGET_FIND_DUPLICATES_RETURN__INDEXES[@]}")"
			return 1
		fi
	done
}

readonly RESOLVE_REQUIREMENTS_CODE__UNKNOWN_NAME=255
RESOLVE_REQUIREMENTS_RETURN__UNKNOWN_NAME=''
resolve-requirements()
{
	local requirements=("$@")

	for requirement in "${requirements[@]}"
	do
		predicate-from-requirement "$requirement"
		local predicate=("${PREDICATE_FROM_REQUIREMENT_RETURN__PREDICATE[@]}")
		if ! predicate-defined "${predicate[0]}"
		then
			RESOLVE_REQUIREMENTS_RETURN__UNKNOWN_NAME="${predicate[0]}"
			return $RESOLVE_REQUIREMENTS_CODE__UNKNOWN_NAME
		fi

		if ! "${predicate[@]}"
		then
			return 1
		fi
	done
}

RESOLVE_REQUIREMENTS_FOR_TARGET_RETURN__ERROR_MESSAGE=''
resolve-requirements-for-target()
{
	local target=$1

	if target-requirements-resolved "$target"
	then
		return
	fi

	target-variant-count "$target"
	local variant_count=$TARGET_VARIANT_COUNT_RETURN__COUNT
	local variant
	for (( variant = 0; variant < variant_count; ++variant ))
	do
		target-requirements "$target" $variant
		local requirements=("${TARGET_REQUIREMENTS_RETURN__REQUIREMENTS[@]}")
		if [[ ${#requirements[@]} == 0 ]]
		then
			target-use-variant "$target" $variant
			return
		fi

		resolve-requirements "${requirements[@]}"
		local retval=$?
		if [[ $retval == $RESOLVE_REQUIREMENTS_CODE__UNKNOWN_NAME ]]
		then
			RESOLVE_REQUIREMENTS_FOR_TARGET_RETURN__ERROR_MESSAGE=$(make-error-message-unknown-requirement "$target" $variant $RESOLVE_REQUIREMENTS_RETURN__UNKNOWN_NAME)
			return 1
		fi

		if [[ $retval == 0 ]]
		then
			target-use-variant "$target" $variant
			return
		fi
	done

	RESOLVE_REQUIREMENTS_FOR_TARGET_RETURN__ERROR_MESSAGE=$(make-error-message-none-requirements-fulfilled "$target")
	return 1
}

RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_FOR_TARGET_RETURN__ERROR_MESSAGE=''
resolve-requirements-and-verify-dependencies-for-target()
{
	local top_target=$1
	local target=$2
	local dependency_path=("${@:3}")

	if is-target-marked "$target"
	then
		return
	fi

	target-mark "$target"

	target-dependencies "$target"
	local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
	local dependency
	for dependency in "${dependencies[@]}"
	do
		target-declaration "$dependency"
		if [ -z "$TARGET_DECLARATION_RETURN__DECLARATION" ]
		then
			RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_FOR_TARGET_RETURN__ERROR_MESSAGE=$(make-error-message-unknown-dependency "$target" "$dependency")
			return 1
		fi

		if ! resolve-requirements-for-target "$dependency"
		then
			RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_FOR_TARGET_RETURN__ERROR_MESSAGE="$RESOLVE_REQUIREMENTS_FOR_TARGET_RETURN__ERROR_MESSAGE"
			return 1
		fi

		if [[ $dependency == $top_target ]]
		then
			RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_FOR_TARGET_RETURN__ERROR_MESSAGE=$(make-error-message-circular-dependency "${dependency_path[@]}")
			return 1
		fi

		if ! resolve-requirements-and-verify-dependencies-for-target "$top_target" "$dependency" "${dependency_path[@]}" "$dependency"
		then
			return 1
		fi
	done
}

resolve-requirements-and-verify-dependencies()
{
	local targets=("$@")

	local target
	for target in "${targets[@]}"
	do
		target-declaration "$target"
		if [ -z "$TARGET_DECLARATION_RETURN__DECLARATION" ]
		then
			printf-error 'unknown target "%s"' "$target"
			return 1
		fi

		if ! resolve-requirements-for-target "$target"
		then
			printf-error "$RESOLVE_REQUIREMENTS_FOR_TARGET_RETURN__ERROR_MESSAGE"
			return 1
		fi

		target-dependencies "$target"
		local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
		if ! resolve-requirements-and-verify-dependencies-for-target "$target" "$target" "$target"
		then
			printf-error "$RESOLVE_REQUIREMENTS_AND_VERIFY_DEPENDENCIES_FOR_TARGET_RETURN__ERROR_MESSAGE"
			return 1
		fi

		targets-unmark "${ALL_TARGETS[@]}"
	done
}

show-target-dependencies()
{
	local target=$1
	local indent=$2

	target-dependencies-recursive "$target"
	local dependencies=("${TARGET_DEPENDENCIES_RECURSIVE_RETURN__DEPENDENCIES[@]}")

	local dependency
	for dependency in "${dependencies[@]}"
	do
		printf "\n%s%s" "$indent" "$dependency"
	done

	printf '\n'
}

show-targets()
{
	local targets=("$@")

	local target="${targets[0]}"
	printf "%s" "$target"
	show-target-dependencies "$target" '    '

	for target in "${targets[@]:1}"
	do
		printf "\n%s" "$target"
		show-target-dependencies "$target" '    '
	done
}

nesting-script-append()
{
	local path=$1
	local arguments=("${@:2}")

	if [[ ${#arguments[@]} == 0 ]]
	then
		return
	fi

	printf "${arguments[@]}" >> "$path"
}

assemble-nesting-script-recursive()
{
	local path=$1
	local targets=("${@:2}")

	local target
	for target in "${targets[@]}"
	do
		if is-target-marked "$target"
		then
			continue
		fi

		target-dependencies "$target"
		local dependencies=("${TARGET_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")
		assemble-nesting-script-recursive "$path" "${dependencies[@]}"

		target-declaration "$target"
		nesting-script-append "$path" '# %s\n' "$TARGET_DECLARATION_RETURN__DECLARATION"

		target-script "$target"
		nesting-script-append "$path" '%s\n' "$TARGET_SCRIPT_RETURN__SCRIPT"

		target-mark "$target"
	done
}

assemble-nesting-script()
{
	local path=$1
	local targets=("${@:2}")

	target-script "$FIRST_STEP"
	local script="$TARGET_SCRIPT_RETURN__SCRIPT"
	if [ -n "$script" ]
	then
		target-declaration "$TARGET_FIRST_STEP_NAME"
		nesting-script-append "$path" '# %s\n' "$TARGET_DECLARATION_RETURN__DECLARATION"
		nesting-script-append "$path" '%s\n' "$script"
	fi

	assemble-nesting-script-recursive "$path" "${targets[@]}"

	target-script "$LAST_STEP"
	local script="$TARGET_SCRIPT_RETURN__SCRIPT"
	if [ -n "$script" ]
	then
		target-declaration "$TARGET_LAST_STEP_NAME"
		nesting-script-append "$path" '# %s\n' "$TARGET_DECLARATION_RETURN__DECLARATION"
		nesting-script-append "$path" '%s\n' "$script"
	fi
}

start-nesting()
{
	local targets=("$@")

	printf-message 'Nesting...'

	path="$WORK_SCRIPT_PATH"
	rm -f "$path"

	nesting-script-append "$path" '#!/bin/bash -ex\n\n'
	assemble-nesting-script "$path" "${targets[@]}"
	chmod u+x "$path"

	deal-with-script "$path"
	if [ $? != 0 ]
	then
		printf-error 'nesting failed. check output for more info.'
		return 1
	fi
}

run-script()
{
	local path=$1

	trap "rm -r $path" EXIT
	"$path"
}

cat-script()
{
	printf '\n'
	cat $1
}

#
# Main

gather-system-info

{ # Deal with arguments
	if ! parse-arguments "$@" || ! validate-and-apply-options
	then
		exit 1
	fi
}

{ # Do the work
	printf-message 'Gathering twigs...'
	if ! gather-twigs $TWIGS_DESCRIPTOR
	then
		exit 1
	fi

	if [[ ${#INPUT_TARGETS[@]} == 0 ]]
	then
		targets=("${REGULAR_TARGETS[@]}")
	else
		targets=("${INPUT_TARGETS[@]}")
	fi

	printf-message 'Checking twigs...'

	check-duplicates "${targets[@]}" &&
	resolve-requirements-and-verify-dependencies "${targets[@]}" $FIRST_STEP $LAST_STEP
	if [ $? != 0 ]
	then
		exit 1
	fi

	do-the-work "${targets[@]}"
}

