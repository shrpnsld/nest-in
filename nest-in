#!/bin/bash

#
# Essentials

SCRIPT_NAME=$(basename $0)

TS_N='\e[0m'
TS_B='\e[1m'
TS_U='\e[4m'
TS_ERROR='\e[0;31m'

ERROR_STYLE_BEGIN=''
ERROR_STYLE_END=''
if [ -t 1 ] && [ $(tput colors) \> 0 ]
then
	ERROR_STYLE_BEGIN="$TS_ERROR"
	ERROR_STYLE_END="$TS_N"
fi

printf-stderr()
{
	printf "$@" >&2
}

printf-error()
{
	printf-stderr "$ERROR_STYLE_BEGIN$SCRIPT_NAME error:$ERROR_STYLE_END "
	printf-stderr "$@"
	printf-stderr '\n'
}

printf-message()
{
	printf "$@"
	printf '\n'
}

#
# Constants

CONFIG_DIR_PATH="$HOME/.config/$SCRIPT_NAME"
CONFIG_FILE_NAME='twigs.txt'
DEFAULT_INPUT_FILE_PATH="$CONFIG_DIR_PATH/$CONFIG_FILE_NAME"

HELP_MESSAGE=\
"${TS_B}USAGE${TS_N}
  ${TS_B}nest-in${TS_N} [${TS_U}-dsr${TS_N}] [${TS_U}targets...${TS_N}] [${TS_U}-k${TS_N}] -- [${TS_U}file${TS_N}]

${TS_B}OPTIONS${TS_N}
  [${TS_U}targets${TS_N}...]  Specify targets to work with.
  ${TS_B}-d${TS_N}            Show dependencies for targets.
  ${TS_B}-s${TS_N}            Show scenarios for targets.
  ${TS_B}--${TS_N} ${TS_U}file${TS_N}       Read nesting info from ${TS_U}file${TS_N}.
  ${TS_B}--${TS_N}            Read nesting info from from ${TS_U}stdin${TS_N}.
  ${TS_B}-h${TS_N}            Show this message.

${TS_B}More information at${TS_N} ${TS_U}https://github.com/shrpnsld/nest-in${TS_N}
"

#
# Options

INPUT_FILE_PATH=''
INPUT_DESRIPTOR=-1
INPUT_TARGETS=()
DO_THE_WORK=:

DELIMITER_PASSED=false

do-the-work()
{
	"$DO_THE_WORK" "$@"
}

#
# Functions

PARAMETER_TYPE_OPTION=1
PARAMETER_TYPE_TARGET=2
PARAMETER_TYPE_DELIMITER=3
PARAMETER_TYPE_BAD=255
PARAMETER_TYPE_RETURN__PARAMETER=''
parameter-type()
{
	local string=$1

	if [ "${string:0:3}" == '--' ] && [ "${#string}" == 2 ]
	then
		return $PARAMETER_TYPE_DELIMITER
	fi

	if [ "${string:0:1}" == '-' ]
	then
		PARAMETER_TYPE_RETURN__PARAMETER="${string#-}"
		return $PARAMETER_TYPE_OPTION
	fi

	if [[ $string =~ ^[a-zA-Z]+[a-zA-Z0-9_\-]*$ ]]
	then
		PARAMETER_TYPE_RETURN__PARAMETER="$string"
		return $PARAMETER_TYPE_TARGET
	fi

	return $PARAMETER_TYPE_BAD
}

PARSE_OPTION_UNKNOWN_OPTION=255
parse-option()
{
	local option=$1
	local value=$2

	case "$option" in
		d)
			DO_THE_WORK=show-dependencies
			;;

		s)
			DO_THE_WORK=show-scenarios
			;;

		h)
			printf "$HELP_MESSAGE"
			exit
			;;

		*)
			return $PARSE_OPTION_UNKNOWN_OPTION
			;;
	esac
}

parse-arguments()
{
	local parameters=("$@")

	local parameter_index
	for (( parameter_index = 0; parameter_index < ${#parameters[@]}; ++parameter_index ))
	do
		local parameter
		parameter-type "${parameters[$parameter_index]}"
		local parameter_type=$?
		parameter="$PARAMETER_TYPE_RETURN__PARAMETER"
		case $parameter_type in
			$PARAMETER_TYPE_OPTION)
				local value="${parameters[$parameter_index + 1]}"
				local option_index
				for (( option_index = 0; option_index < ${#parameter}; ++option_index ))
				do
					local option="${parameter:$option_index:1}"
					parse-option "$option" "$value"
					local retval=$?
					case $retval in
						$PARSE_OPTION_UNKNOWN_OPTION)
							printf-error 'unknown option "%s"' "$option"
							return 1
							;;

						*)
							(( parameter_index += retval ))
							: # so the result of arithmetic above does not considered as a result of case-clause execution
							;;
					esac
				done

				continue
				;;

			$PARAMETER_TYPE_TARGET)
				INPUT_TARGETS+=("$parameter")
				;;

			$PARAMETER_TYPE_DELIMITER)
				(( ++parameter_index ))
				DELIMITER_PASSED=true
				INPUT_FILE_PATH="${parameters[$parameter_index]}"
				break
				;;

			$PARAMETER_TYPE_BAD)
				printf-error 'bad parameter format "%s"' "$parameter"
				return 1
				;;
		esac
	done
}

validate-options()
{
	if [ -n "$INPUT_FILE_PATH" ]
	then
		exec 3< "$INPUT_FILE_PATH"
		INPUT_DESCRIPTOR=3
	elif $DELIMITER_PASSED
	then
		INPUT_DESCRIPTOR=0
	else
		if ! [ -r "$DEFAULT_INPUT_FILE_PATH" ]
		then
			printf-error 'failed to open config file "%s"' "$DEFAULT_INPUT_FILE_PATH"
			exit 1
		fi

		exec 3< "$DEFAULT_INPUT_FILE_PATH"
		INPUT_DESCRIPTOR=3
	fi

	if [ "$DO_THE_WORK" == : ]
	then
		DO_THE_WORK=start-nesting
	fi
}

#PLATFORM_OS_NAME=''
#detect-platform()
#{
#	if [ -f /etc/os-release ]
#	then
#		# freedesktop.org and systemd
#		. /etc/os-release
#		PLATFORM_OS_NAME=$NAME
#		VER=$VERSION_ID
#	elif type lsb_release >/dev/null 2>&1
#	then
#		# linuxbase.org
#		PLATFORM_OS_NAME=$(lsb_release -si)
#		VER=$(lsb_release -sr)
#	elif [ -f /etc/lsb-release ]
#	then
#		# For some versions of Debian/Ubuntu without lsb_release command
#		. /etc/lsb-release
#		PLATFORM_OS_NAME=$DISTRIB_ID
#		VER=$DISTRIB_RELEASE
#	elif [ -f /etc/debian_version ]
#	then
#		# Older Debian/Ubuntu/etc.
#		PLATFORM_OS_NAME=Debian
#		VER=$(cat /etc/debian_version)
#	else
#		# Fall back to uname, e.g. "Linux <version>", also works for BSD, etc.
#		PLATFORM_OS_NAME=$(uname -s)
#		VER=$(uname -r)
#	fi
#}

is-target-declaration()
{
	local line=$1

	[[ $line =~ ^[a-zA-Z]+[a-zA-Z0-9_\-]*[\ \t]*$ ]] ||
	[[ $line =~ ^[a-zA-Z]+[a-zA-Z0-9_\-]*[\ \t]*\/([\ \t]*[a-zA-Z]+[a-zA-Z0-9_\-]*)*[\ \t]*$ ]]
}

READ_TARGET_RETURN__TARGET=''
read-target()
{
	local line=$1

	local old_IFS="$IFS"
	IFS=$' '

	line=(${line[@]})
	READ_TARGET_RETURN__TARGET="${line[0]}"

	IFS="$old_IFS"
}

READ_DEPENDENCIES_RETURN__DEPENDENCIES=()
read-dependencies()
{
	local line=$1

	READ_DEPENDENCIES_RETURN__DEPENDENCIES=()

	if [[ $line != */* ]]
	then
		return
	fi

	local old_IFS="$IFS"
	IFS=$' '

	READ_DEPENDENCIES_RETURN__DEPENDENCIES=(${line#*/})

	IFS="$old_IFS"
}

variable-name-from-target()
{
	local string=$1

	tr '-' '_' <<< "$string"
}

PEEK_FILE__RETURN=''
peek-file()
{
	local descriptor=$1

	if [ -z "$PEEK_FILE__RETURN" ]
	then
		read -u $descriptor -r PEEK_FILE__RETURN
		if [ $? != 0 ]
		then
			return 1
		fi
	fi
}

READ_FILE__RETURN=''
read-file()
{
	local descriptor=$1

	if [ -n "$PEEK_FILE__RETURN" ]
	then
		READ_FILE__RETURN="$PEEK_FILE__RETURN"
		PEEK_FILE__RETURN=''
	else
		read -u $descriptor -r READ_FILE__RETURN
		if [ $? != 0 ]
		then
			return 1
		fi
	fi
}

next-non-empty-line()
{
	local descriptor=$1

	while true
	do
		peek-file $descriptor
		if [ $? != 0 ]
		then
			return 1
		fi

		if [ -n "$PEEK_FILE__RETURN" ]
		then
			break
		fi
	done
}

READ_TARGET_DECLARATION_RETURN__TARGET=''
read-target-declaration()
{
	local descriptor=$1

	READ_TARGET_DECLARATION_RETURN__TARGET=''

	read-file $descriptor
	local line="$READ_FILE__RETURN"
	if [ $? != 0 ]
	then
		return 1
	fi

	read-target "$line"
	local target="$READ_TARGET_RETURN__TARGET"

	read-dependencies "$line"
	local dependencies=("${READ_DEPENDENCIES_RETURN__DEPENDENCIES[@]}")

	local target_variable_name=$(variable-name-from-target "$target")
	eval "NEST_DEPENDENCIES_${target_variable_name}=(${dependencies[@]})"

	READ_TARGET_DECLARATION_RETURN__TARGET="$target"
}

READ_TARGET_SCENARIO_RETURN__SCENARIO=''
read-target-scenario()
{
	local descriptor=$1

	READ_TARGET_SCENARIO_RETURN__SCENARIO=''

	while true
	do
		read-file $descriptor
		if [ $? != 0 ]
		then
			return 255
		fi

		local line="$READ_FILE__RETURN"
		if [ -z "$line" ]
		then
			return
		fi

		READ_TARGET_SCENARIO_RETURN__SCENARIO+="$line"$'\n'
	done
}

GATHER_TWIGS_RETURN__TARGETS=()
gather-twigs()
{
	local descriptor=$1

	GATHER_TWIGS_RETURN__TARGETS=()

	local old_IFS="$IFS"
	IFS=$'\n'

	while true
	do
		while true
		do
			next-non-empty-line $descriptor && peek-file $descriptor && is-target-declaration "$PEEK_FILE__RETURN" && read-target-declaration $descriptor
			if [ $? != 0 ]
			then
				break
			fi

			GATHER_TWIGS_RETURN__TARGETS+=("$READ_TARGET_DECLARATION_RETURN__TARGET")
		done

		read-target-scenario $descriptor
		if [ $? != 0 ]
		then
			break
		fi
        
		local target="$READ_TARGET_DECLARATION_RETURN__TARGET"
		local variable_name=$(variable-name-from-target "$target")
		printf -v "NEST_SCENARIO_${variable_name}" '%s' "$READ_TARGET_SCENARIO_RETURN__SCENARIO"
		unmark-target "$target" # basically create information about mark
	done

	IFS="$old_IFS"
}

array-contains-item()
{
	local item=$1
	local array=("${@:2}")

	local current
	for current in ${array[@]}
	do
		if [ "$current" == "$item" ]
		then
			return 0
		fi
	done

	return 1
}

check-all-targets-exist()
{
	local targets=("$@")

	local any_errors=false
	local target
	for target in "${targets[@]}"
	do
		dependencies-for-target "$target"
		local dependencies=("${DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES[@]}")
		for dependency in "${dependencies[@]}"
		do
			if ! array-contains-item "$dependency" "${targets[@]}"
			then
				printf-error 'unknown dependency "%s" for target "%s"' "$dependency" "$target"
				any_errors=true
			fi
		done
	done

	! $any_errors
}

FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH=''
find-circular-dependencies-impl()
{
	local target_to_depend=$1
	local targets=("${@:2}")

	if array-contains-item "$target_to_depend" "${targets[@]}"
	then
		FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH="$target_to_depend"
		return 0
	fi

	local target
	for target in "${targets[@]}"
	do
		if is-target-marked "$target"
		then
			continue
		fi

		mark-target "$target"

		dependencies-for-target "$target"
		local dependencies=("${DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES[@]}")
		find-circular-dependencies-impl "$target_to_depend" "${dependencies[@]}"
		if [ $? == 0 ]
		then
			FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH="$target -> $FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH"
			return 0
		fi
	done

	return 1
}

find-circular-dependencies()
{
	local target=$1

	dependencies-for-target "$target"
	local dependencies=("${DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES[@]}")
	find-circular-dependencies-impl "$target" "${dependencies[@]}"
	local retval=$?
	FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH="$target -> $FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH"
	unmark-targets "${dependencies[@]}"
	return $retval
}

check-theres-no-circular-dependencies()
{
	local targets=("$@")

	local target
	for target in "${targets[@]}"
	do
		if find-circular-dependencies "$target"
		then
			printf-error 'circular dependency was found: %s' "$FIND_CIRCULAR_DEPENDENCIES_RETURN__DEPENDENCY_PATH"
			return 1
		fi
	done
}

check-twigs()
{
	check-all-targets-exist "${targets[@]}" &&
	check-theres-no-circular-dependencies "${targets[@]}"
}

DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES=()
dependencies-for-target()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	eval "DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES=("\${NEST_DEPENDENCIES_${variable_name}[@]}")"
}

dependencies-for-target-recursive()
{
	local target=$1

	dependencies-for-target "$target"
	local dependencies=("${DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES[@]}")
	if [[ ${#dependencies[@]} == 0 ]]
	then
		return
	fi

	printf '  %s\n' "${dependencies[@]}"
	for dependency in "${dependencies[@]}"
	do
		dependencies-for-target-recursive "$dependency"
	done
}

SCENARIO_FOR_TARGET_RETURN__SCENARIO=''
scenario-for-target()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	eval "SCENARIO_FOR_TARGET_RETURN__SCENARIO=(\"\$NEST_SCENARIO_${variable_name}\")"
}

is-target-marked()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_installed="NESTS_MARKED_${variable_name}"
	${!target_installed}
}

unmark-target()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_installed="NESTS_MARKED_${variable_name}"
	printf -v "$target_installed" false
}

mark-target()
{
	local target=$1

	local variable_name=$(variable-name-from-target "$target")
	local target_installed="NESTS_MARKED_${variable_name}"
	printf -v "$target_installed" true
}

unmark-targets()
{
	local targets=("$@")

	for target in "${targets[@]}"
	do
		unmark-target "$target"
	done
}

show-dependencies()
{
	local targets=("$@")

	local target="${targets[0]}"
	printf "${TS_U}%s${TS_N}\n" "$target"
	dependencies-for-target-recursive "$target" | sort | uniq

	for target in "${targets[@]:1}"
	do
		printf '\n'
		printf "${TS_U}%s${TS_N}\n" "$target"
		dependencies-for-target-recursive "$target" | sort | uniq
	done
}

show-scenarios()
{
	local targets=("$@")

	local target="${targets[0]}"
	printf "${TS_U}%s${TS_N}\n" "$target"

	scenario-for-target "$target"
	local scenario="$SCENARIO_FOR_TARGET_RETURN__SCENARIO"
	printf '%s' "$scenario"

	for target in "${targets[@]:1}"
	do
		printf '\n'
		printf "${TS_U}%s${TS_N}\n" "$target"

		scenario-for-target "$target"
		local scenario="$SCENARIO_FOR_TARGET_RETURN__SCENARIO"
		printf '%s' "$scenario"
	done
}

start-nesting()
{
	local targets=("$@")

	local target
	for target in "${targets[@]}"
	do
		if is-target-marked "$target"
		then
			continue
		fi

		dependencies-for-target "$target"
		local dependencies=("${DEPENDENCIES_FOR_TARGET_RETURN__DEPENDENCIES[@]}")
		if [ ${#dependencies[@]} != 0 ]
		then
			start-nesting "${dependencies[@]}"
		fi

		scenario-for-target "$target"
		local scenario="$SCENARIO_FOR_TARGET_RETURN__SCENARIO"

		# the easiest way to do this,
		# which also allows to keep user-set variables between scenarios
		printf '%s' "$scenario" > ./scenario.tmp
		trap 'rm -f ./scenario.tmp' EXIT
		. ./scenario.tmp
		if [ $? != 0 ]
		then
			printf-error 'failed to install "%s"' "$target"
			exit
		fi

		mark-target "$target"
	done
}

#
# Main

{ # Deal with arguments
	parse-arguments "$@" && validate-options
	if [ $? != 0 ]
	then
		exit 1
	fi
}

{ # Do the work
	gather-twigs $INPUT_DESCRIPTOR
	targets=("${GATHER_TWIGS_RETURN__TARGETS[@]}")

	check-twigs
	if [ $? != 0 ]
	then
		exit 1
	fi

	if [[ ${#INPUT_TARGETS[@]} == 0 ]]
	then
		INPUT_TARGETS=("${targets[@]}")
	fi

	do-the-work "${INPUT_TARGETS[@]}"
}

